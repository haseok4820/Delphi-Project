unit uDM;

interface

uses
  System.SysUtils, System.Classes, System.JSON, PNGImage, Windows, Graphics, StrUtils,
  Vcl.Controls, Vcl.ComCtrls, Vcl.ExtCtrls, Vcl.Forms, Vcl.ExtActns, FireDAC.Stan.Intf, Registry,
  Vcl.StdCtrls, Frame_YN, Frame_CheckBox, inifiles, Messages, RegularExpressions,
  FireDAC.Stan.Option, FireDAC.Stan.Error, ShellApi, Winapi.TlHelp32, Winapi.WinINet,
  FireDAC.UI.Intf, FireDAC.Phys.Intf, FireDAC.Stan.Def, FireDAC.Stan.Pool,
  FireDAC.Stan.Async, FireDAC.Phys,
  FireDAC.VCLUI.Wait, FireDAC.Phys.FBDef, FireDAC.Stan.Param, FireDAC.DatS,
  FireDAC.DApt.Intf, FireDAC.DApt, Data.DB,
  FireDAC.Comp.DataSet, FireDAC.Comp.Client, FireDAC.Phys.IBBase,
  FireDAC.Phys.FB, Vcl.Dialogs, Vcl.Touch.GestureMgr, IdBaseComponent, IdComponent, IdTCPConnection, IdTCPClient, IdHTTP,
  System.Notification, IdIOHandler, IdIOHandlerSocket, IdIOHandlerStack, IdSSL, IdSSLOpenSSL, System.Net.URLClient,
  System.Net.HttpClient, System.Net.HttpClientComponent;

Function Wow64DisableWow64FsRedirection(Var Wow64FsEnableRedirection: LongBool): LongBool; StdCall; // Win64 리다이렉트 해제
External 'Kernel32.dll' Name 'Wow64DisableWow64FsRedirection';
Function Wow64EnableWow64FsRedirection(Wow64FsEnableRedirection: LongBool): LongBool; StdCall; // Win64 리다이렉트 재실행
External 'Kernel32.dll' Name 'Wow64EnableWow64FsRedirection';
function IsWow64Process(Handle: THandle; var IsWow64: BOOL): BOOL; stdcall; external 'kernel32.dll'; // Win64/32 체크

type
  KNOWNFOLDERID = TGUID;
  TDyanmicArr_Str = array of String;

  TFileInfos = record
    sProcessName: String; // 프로세스명
    sExeName: String; // 실행파일명
    sPath: String; // 파일 경로
    sVersion: String; // 파일 버전
  end;

  TMachineInfo = record
    iPort: Integer; // 포트번호
    iType: Integer; // 장치유형
    iKit: Integer; // 주방출력
    iKit_Spc: Integer; // 주방 특별출력
    iMachineType: Integer; // 장치기종(학장포트 전용)
  end;

  TResult_IS = record
    Result_int: Integer;
    Result_Str: String;
  end;

  TResult_BS = record
    Result_Bool: Boolean;
    Result_Str: String;
  end;

  TStock_Category = record
    sCODE: String;
    sName: String;
  end;

  TStock_Info = record
    sStockCode: String; // 상품코드
    sStockName: String; // 상품명
    iStockAMT: Integer; // 판매금액
    sGubunCode: String; // 상품분류
    sKitPrn: String; // 주방분류
    iMaeipAMT: Integer; // 매입단가(추가요금)
    iNowMaeip: Integer; // 할인율(추가시간)
    sStandard: String; // 규격(상품설명)
    sUnit: String; // 단위(시간)
    sVAT: String; // 상품구분
    iQTY: Integer; // 특정메뉴
    sSETCODE: String; // 세트코드

    bCHk: Boolean; // 체크유무
    bView: Boolean; // 표시유무
  end;

  TStock_Set = record
    sCODE: String; // 세트코드
    sSETNAME: String; // 세트명
    iSEQ: array of Integer; // 연결그룹 코드
    iCNT: Integer; // 수량
    iSETTYPE: Integer; // 세트 유형
  end;

  TStock_SetMenus = record
    iSEQ: Integer; // 구성순번
    sName: String; // 구성명
    sOption_CODE: array of String; // 옵션 코드
    sOption_Name: array of String; // 옵션 명
    iOption_AMT: array of Integer; // 옵션 가격
    iOption_SEQ: array of Byte; // 옵션 순번
    sOption_DateTime: array of String; // 옵션 처리시간
  end;

  TMenu_Category = record
    sCategory_Name: String;
    sCategory_BackColor: String;
    sCategory_FontColor: String;
  end;

  TMenu_Info = record
    sMenu_CODE: String;
    sMenu_Name: String;
    iMenu_AMT: Integer;
    sMenu_BackColor: String;
    sMenu_FontColor: String;
  end;

  TFloor_Info = record
    // iFloor: Byte;
    sFloorName: String;
    iTableCnt: Byte;
  end;

  TTable_Info = record
    bUsed: Boolean;
    // iFloorNo: Byte;
    // iTableNo: Byte;
    sTableName: String;
    sTableTag: String;
    iTable_X: SmallInt;
    iTable_Y: SmallInt;
    iTable_W: SmallInt;
    iTable_H: SmallInt;

  end;

  TLocker_info = record
    iSEQ: Word; // 락커 번호
    sTAG: String; // 태그값
    sUSED: String; // 락커 사용유무 : [N : 미사용(기본값), Y : 사용중]
    sSTATIC: String; // 태그 등록유무 : [N : 등록안됨(기본값), Y : 등록됨 ]
  end;

  TPrnOption = record
    sTitle: String; // 출력타이틀
    iTop_Len: Integer; // 상단여백
    iBot_Len: Integer; // 하단여백
    iPrnCnt: Integer; // 출력수량
    BS_Prn: array of TResult_BS; // 출력유무
    BS_Ext: array of TResult_BS; // 확대유무
    slMemo: TStringList; // 하단 문구
  end;

  TPos_Info = record
    iSEQ: Integer; // 순번(포스번호)
    bConn: Boolean; // 연결유무
    shost: String; // 장치IP
    sName: String; // 장치호칭
    sAppName: String; // 관리앱명

  end;

  TDID_Opations = record
    // AirDID.ini
    DIDViewType: Integer; // DID 유형
    iVoiceType: Integer; // 호출 유형 (0 : Bell, 1 : TTS)
    ReadyOrderUp: String; // 완료 타이틀명
    TableUP: String; // 준비중 타이틀명
    OrdClearTime: String; // 완료주문 표시시간(0은 무제한)
    ShowMenuList: Boolean; // 호출시 주문메뉴 표시
    DspSetView: Boolean; // 호출시 세트메뉴옵션도 함꼐 표시
    useTopMost: Boolean; // DID 맨 앞에 표시
    OrdNoneView: Boolean; // 준비중 주문 표시안함
    useAirCall: Boolean; // AirCall 사용유무(체크시 Delay 없음)
    DelData: Boolean; // 금일 매출 외 주문 삭제처리
    useViewCount: Boolean; // 대기건수 표시(유형 5번 전용)
    OrdCallFormTimeout: Integer; // 호출창 표시시간(0 무제한)
    ShowDualMonitor: Boolean;
    usePosView: Boolean; // 특정 포스건만 표시유무
    sPosList: String; // ㄴ포스리스트

    MediaMute: Boolean;

    // Servers.ini
    sHostIP: String;
    sAddress: String;

    // Airpos.ini
    GMZName: String; // 상호명
    useDualMonitor: Boolean; // 보조모니터 유무
    DspKITmonitor: Integer; // 주방현황판 표시 유무
    DspSetMenu: String; // 세트메뉴 구분값
    DspDisplayFileList: array [1 .. 5] of String; // 동영상 재생 목록

  end;

  TIdHTTP_Thread = class(TThread)
    sContentType: String;
    sURL: String;
    iProtocal: Integer; // 0 : HTTP, 1 : HTTPS
    iMethod: Integer; // 0 : Get, 1 : POST
    bRecv: Boolean; // 응답유무
    bUTF: Boolean; // UTF 변환 유무
    iTimeout: Integer; // Timeout
    Result_IS: TResult_IS; // 응답결과
  protected
    procedure Execute; override;
    constructor Create;
  end;

  TDownloadURL_Thread = class(TThread)
    sURL: String; // 다운로드 경로
    sSavePath: String; // 저장 위치

    //
    iMAX, iNOW: Cardinal;
    sStatusCode: TURLDownloadStatus;
    sStatusText: String;
    bCancel: Boolean;
    bAutoOpen: Boolean;
    bComplete: Boolean;
    bOK: Boolean;
    procedure DownAfterDownload(Sender: TObject);
    procedure DownProgress(Sender: TDownLoadURL; Progress, ProgressMax: Cardinal; StatusCode: TURLDownloadStatus; StatusText: String;
      var Cancel: Boolean);
  protected
    procedure Execute; override;
  public
    constructor Create(CreateSuspended: Boolean);
    destructor Destory;
  end;

  TDM = class(TDataModule)
    FDConn: TFDConnection;
    FDDriver: TFDPhysFBDriverLink;
    FDQ: TFDQuery;
    ColorDialog1: TColorDialog;
    OpenDialog: TFileOpenDialog;
    WinNotification: TNotificationCenter;
    SaveDialog: TSaveDialog;
    Timer_DownloadChk: TTimer;
    HttpClient: TNetHTTPClient;
    procedure DataModuleCreate(Sender: TObject);
    procedure DataModuleDestroy(Sender: TObject);

    procedure SetLog(WirteText: String);
    procedure GetENVList;
    procedure Timer_DownloadChkTimer(Sender: TObject);
  private
    { Private declarations }
  public
    { Public declarations }

    procedure SetPngAlphaBlend(img: TPngImage; const Alpha: Byte);
    procedure SetRound(comp: TObject);
    procedure iniInfo(iType: Integer; siniName: String);
    procedure TouchKeyBoard;
    procedure SetBG(iType: Integer);

    procedure Send_Msg(MSG: String);
    procedure Recv_Msg(var MSG: TWMCopyData); message WM_COPYDATA;

    function SetFrameCheckBOX(bYN: Boolean; FrameCheckBox: TFrame_ENV_CHECKBOX): TResult_IS;
    function Image_CheckBOX(iTag: Integer; FrameCheckBox: TFrame_ENV_CHECKBOX): TResult_IS;
    function Label_YN(bYN: Boolean; FrameYN: TFrame_ENV_YN): TResult_IS;
    function ControlProgram(iType: Byte; sProgramPath: String): TResult_IS;
    function GetList(Title: String; arrList: array of String): TResult_IS;
    function GetLogin(Title: String): TResult_IS;

    function GetPopup(iType: Byte; Title, sMsg, imageName: String): TResult_IS; overload;
    function GetPopup(iType: Byte; sMsg: String): TResult_IS; overload;
    function GetPopup(sMsg: String): TResult_IS; overload;

    function GetOpen(iType: Integer): TResult_IS;
    function GetComPort: TResult_IS;
    function IPValueCheck(sIP_Address: String): Boolean;
    function SetTRegistry(SetType: Integer; SetName, SetValue: String): TResult_IS;
    function GetExecute(ProcessName: String): TResult_IS;
    function GetfileInfo(): TFileInfos;
    procedure OpenExplorer(sPath: String);

    procedure ShowNotification(sName, sTitle, sMsg: String); overload;
    procedure ShowNotification(sName, sMsg: String); overload;
    procedure DelNotification(sName: String);

    function FileVersion(sPath: String): String;
    procedure FileUpdateChk;
    procedure FileDownload(sDonwloadURL, sFileName: String)overload;
    procedure FileSaveComplete;

    function HTTP_Send(sURL, sMethod, sContent, sEncoding: String): String;

    function KorCheck(sText: String): Boolean;
    function AnsiFormat(sText: String): AnsiString; overload;
    function AnsiFormat(sText: String; iCuting: Word): AnsiString; overload;

    function ColorHex(sColor: String): String;
    function AnsiLen(sText: STring): Integer;
    function LabelFontSize(SetLabel_Control: TLabel): Byte;
    function CountStrings(sText, FindText: String): Word;
    function CopyArr(const c: array of String): TDyanmicArr_Str;
    function JsonParserString(JsonVal: String): String;

    procedure WControl_MouseDown(Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: Integer);

    // =================== DB
    function DBConnect: Boolean;
    function DBDisConnect: Boolean;
    procedure DBSQLClear;

    function DBCodeChk(sTable, sColumn, sChkCode: String): Boolean;
    function GetStocks: Boolean;
    function GetSets: Boolean;
    function GetSetMenus: Boolean;
    function GetMenuCategros: Boolean;
    function GetMenus: Boolean;
    function GetTable: Boolean;
    function GetlockerTag: Boolean;

  end;

function SHGetKnownFolderPath(const GUID: KNOWNFOLDERID; dwFlags: DWORD; hToekn: THandle; out ppszPath: PWideChar): HRESULT; stdcall;
  external 'Shell32.dll';

const
  SideNav_ENV = 0; // 환경설정
  SideNav_Data = 1; // 데이터 관리
  SideNav_System = 2; // 타 장비 관리

  MENUAL_PATH = 'Menual\';
  IMG_PATH = 'image\';
  Chr13 = #13#10;

  cSelLabel_Font = clWhite;
  cSelLabel_BG = $00A4580B;
  cLabel_Font = clBlack;
  cLabel_BG = clWhite;

  iMENU_CATEGORY_MAX = 50;
  iMENU_MAX = 125;

var
  DM: TDM;
  bFoodcafeRestart: Boolean = False;
  bWinMsg_Recv: Boolean = False;
  bUpdate: Boolean = False; // 최신버전 유무 (True : 업데이트 가능,  False : 최신버전 상태)
  ProgramPath, ProgramVer: String;
  PrnLineCnt: Byte;
  bWin32: Boolean = True;
  DownloadURL: TDownloadURL_Thread;

  StoreName: String = '에어포스 매장테스트'; // 매장명
  StoreOwner: String = '천태진'; // 대표자
  StoreType: String = '일반음식점'; // 업종
  StoreSeq: String = '214-87-26177'; // 사업자번호
  StoreTel: String = '02-1588-9218'; // 전화번호
  StoreAddr1: String = '서울 영등포구 경인로 775'; // 매장주소
  StoreAddr2: String = '에이스하이테크시티 1동 721호'; // 매장상세주소

  HostIP: String = '127.0.0.1'; // DB 주소
  DBPath: String = 'C:\FOODCAFE\Database'; // DB 경로
  Posno: Integer = 1; // 포스번호
  arrkitCommIP: array [1 .. 20] of String; // 인쇄그룹 별도지정
  NotCommSvr: Boolean = True;

  GMZNO: String = ''; // ASP 번호
  useAutoDown: Integer = 0; // ASP 메뉴다운로드 유형 (0 : 사용안함 1 : 매장다운로드 2 : 본사다운로드)
  useNOTStock: Boolean = False; // 상품정보 수정불가유무
  CloseNoUpdate: Boolean = False; // 마감자료 변경불가유무
  NotSaleSend: Boolean = False; // ASP 매출전송안함
  // 결제

  VANGB: Integer = 0; // VAN구분
  TermNo: String = ''; // VAN TID
  useSecuAgent: Boolean = False; // 리더기 사용유무
  useSecuAgentport: Integer = 0; // 리더기포트

  useSecuRefAppr: Boolean = False; // 단말기 사용유무
  useSecuRefPort: Integer = 0; // 단말기 포트

  useSignPad: Boolean = False; // 서명패드 사용유무
  SignPadNo: Integer = 0; // 서명패드 포트

  Port_List: array [1 .. 4] of TMachineInfo; // 장치정보
  ExtPort_List: array [1 .. 3] of TMachineInfo; // 확장포트 장치정보
  RecPrnType: Integer = 0; // 영수증 장치기종(or속도값)
  KitPrnType: Integer = 0; // 주방 장치기종(or속도값)
  KitDriverPrint: Boolean = False; // 주방드라이버 사용유무

  ReceiptPrn: Integer = 0; // 영수증 발행 방식
  KitFontSize: Integer = 0; // 주방 확대폰트
  UseggPrn: Boolean = False; // 고객주문서 발행유무

  NewDelv: Boolean = False; // 신배달 사용유무
  vDelvPort: String = '사용안함'; // 가상포트 번호
  vDelvRec: Boolean = False; // 가상포트 영수증 전송 유무
  vDelvKitNumber: Integer = 0; // 가상포트 주방전송 번호

  // 설정
  optCloseSale: Boolean = False; // 포스별 개별마감
  useSale24: Boolean = False; // 영업자동마감
  TimeOrigin: String = '04:00'; // 영업마감 기준시간
  useAdvance: Boolean = False; // 판매유형 ( 0 : 좌석제 1 : 선불제 )
  useTimeSale: Boolean = False; // 시간제모드 ( 0 : 사용안함 1 : 사용함)
  TimeSaleStaticLock: Boolean = False; // 고정락커 사용유무
  TimeAutoLockerLayer: Boolean = False; // 락커/태그사용안함 유무
  TimeTableTag: Boolean = False; // 테이블 태그사용 유무
  TimeSaleNoAdvance: Boolean = False; // 시간 후불결제 사용유무
  useTimeOverChg: Boolean = False; // 입실시간 변경기능 사용유무
  useTimeChange: Boolean = False; // 추가시간 바로적용 사용유무
  FoodCourt: Boolean = False; // 푸드코트
  TableSizeGB: Integer = 1; // 좌석 사이즈 유형 [크게 (6X6), 보통 (7X8), 작게 (9X12)]

  QuesAppr: Boolean = False; // 결제전 질의창 사용유무
  useOrdCashRecp: Boolean = False; // 현금결제시 현금영수증 발행유무 확인
  useIDSave: Boolean = False; // 로그인 정보 저장유무

  ordFuncType: Boolean = False; // 기타기능 바로가기 사용유무
  arrLetsGoordID: array [1 .. 9] of Integer; // 기타기능 바로가기

  useDualMonitor: Boolean = False; // 보조모니터 사용유무
  DualDisplayText: String = '';
  DualDisplayFile: array [1 .. 5] of String; // 보조모니터 미디어파일명

  recCardSlip: Boolean = True; // 고객용주문내역 인쇄
  BCPaper: Boolean = True; // 고객용

  // 설정 (AirControl)
  { 서버 전용 }
  AC_bYN: Boolean = False; // 서버 유무
  arrPos_Info: array of TPos_Info; // 연결된 장치 리스트

  DID_Opations: TDID_Opations; // DID 원격설정 리스트

  { 클라이언트 전용 }
  AC_sHostIP: String = ''; // 서버 IP
  AC_iPort: Integer = 20228; // 서버 포트
  AC_iEXEType: Integer = 0; // 관리 프로그램
  AC_Refrush: Boolean = False; // 변경사항 유무
  {
    0: NOne
    1; foodacfe
    2: kiosk
    3: did
    4: airServer
    5: airTrain
  }

  // =================(AirControl)

  // DB
  bSQLExecute: Boolean = False;

  arrStockCategoryInfo: array of TStock_Category; // 상품분류 목록
  arrStockInfo: array of TStock_Info; // 상품목록
  arrStockSet: array of TStock_Set; // 세트분류
  arrStockSetMenus: array of TStock_SetMenus; // 세트그룹 목록
  arrMenuCategory: array of TMenu_Category; // 배치 분류 목록
  arrMenu: array of array of TMenu_Info; // 배치 상품 목록

  arrFloor: array of TFloor_Info; // 층수 목록
  arrTable: array of array of TTable_Info; // 좌석 목록

  arrLocker: array of TLocker_info; // 락커 목록
  // =================

  arrVanList: array [0 .. 12] of String = (
    '카드 사용안함',
    'KS',
    'FIRST',
    'NICE',
    'JTNET',
    'KOCES',
    'KIS',
    '금결원(KFTC)',
    'KICC',
    'DAOU',
    'KCP',
    '스마트로',
    'KOVAN'
  );

  arrVanFileName: array [0 .. 12] of String = (
    '',
    'KS.msi',
    'FIRST.zip',
    'NICE.exe',
    '',
    'KOCES.exe',
    'KIS.exe',
    'KFTC.exe',
    'KICC.zip',
    'DAOU.zip',
    'KCP.exe',
    'SMARTRO.exe',
    'KOVAN.exe'
  );

  ExtPortList: array [0 .. 15] of String = (
    '사용안함',
    'COM1',
    'COM2',
    'COM3',
    'COM4',
    'COM5',
    'COM6',
    'COM7',
    'COM8',
    'COM9',
    'COM10',
    'COM11',
    'COM12',
    'COM13',
    'COM14',
    'COM15'
  );

  arrAspAutoDown: array [0 .. 2] of String = (
    '메뉴 다운로드 사용안함',
    '매장ASP 상품사용',
    '본사ASP 상품사용'
  );

  arrSideNAv_Category: array [0 .. 2] of String = (
    '사용자 환경설정',
    '데이터관리',
    '원격관리/설정'
  );
{$IFDEF DEBUG}
  arrENV_Category: array [0 .. 4] of String = (
{$ELSE}
  arrENV_Category: array [0 .. 3] of String =
  (
{$ENDIF}
    '매장관리',
    '일반설정',
    '장치관리',
    '결제관리'
{$IFDEF DEBUG},
    '상품관리(Demo)'
{$ENDIF}
  );

  arrENV_Nav: array of array of String;

  arrData_Category: array [0 .. {$IFDEF DEBUG}2 {$ELSE} 1{$ENDIF}] of String = (
    '판매상품관리',
    '배치관리'
{$IFDEF DEBUG},
    '회원관리' {$ENDIF}
  );

  arrData_Nav: array of array of String;

  arrSystem_Category: array [0 .. 0] of String = (
    '원격 관리/설정'
  );
  arrSystem_Nav: array of array of String;

  arrPrnList: array [0 .. 2] of String = (
    '영수증',
    '고객주문서',
    '주방주문서'
  );

  arrRecPrnType_OPTION: array [0 .. 8] of String = (
    '9600BPS',
    '38400INIT',
    '19200BPS',
    'POVI',
    '115200BPS',
    'KM-1000/P-100',
    '38400NOINIT',
    '*SRP-350*',
    'KOCES-T5500'
  );

  arrKitPrnType_OPTION: array [0 .. 12] of String = (
    '9600BPS-STP',
    '115200BPS',
    '19200BPS',
    '38400BPS',
    'CALL-1CH',
    'CALL-2CH',
    '*SRP350*',
    'CALLSTAR',
    '시스콜호출벨',
    '링크맨호출벨',
    'LEETEK호출벨',
    'NECALL',
    'KAKAO-SMS'
  );

  arrExtPrnType_OPTION: array [0 .. 12] of String = (
    '9600BPS-STP/SRP',
    '115200BPS',
    '19200BPS',
    '38400BPS',
    'Call-1ch',
    'Call-2ch',
    '*SRP350*',
    'CallStar',
    '시스콜호출벨',
    '링크맨호출밸',
    'LEETEK호출벨',
    'NECALL',
    'KAKAO-SMS'
  );

  arrPortType_OPTION: array [0 .. 16] of String = (
    '사용안함',
    '영수증프린터',
    '고객표시장치',
    'RF 리더기',
    'CALL-ID',
    '무선단말기',
    '라벨프린터',
    '시리얼리더기',
    '저울',
    '호출벨',
    '동전계수기',
    '주방-1',
    '주방-2',
    '주방-3',
    '주방-4',
    '주방-5',
    '주방-6'
  );

  arrPortType_Kit: array [0 .. 5] of String = (
    '미사용',
    '주방-(특별1)',
    '주방-(특별2)',
    '주방-(특별3)',
    '주방-(특별4)',
    '주방-(특별5)'
  );

  arrPortType_OPTION2: array [0 .. 16] of String = (
    '사용안함',
    '주방-1',
    '주방-2',
    '주방-3',
    '주방-4',
    '주방-5',
    '주방-6',
    '영수증프린터',
    '고객표시장치',
    'RF 리더기',
    'CALL-ID',
    '무선단말기',
    '라벨프린터',
    '시리얼리더기',
    '저울',
    '호출벨',
    '동전계수기'
  );

  arrvKitSendList: array [0 .. 9] of String = (
    '전송안함',
    '주방-1',
    '주방-2',
    '주방-3',
    '주방-4',
    '주방-5',
    '주방-6',
    '주방-(특별1)',
    '주방-(특별2)',
    '주방-(특별3)'
  );

  arrPrnOptionList: array [0 .. 2] of TPrnOption; // 출력유무, 확대유무(N, B)
  arrPrnOptionList_RecCation: array [0 .. 1] of array [0 .. 9] of string = (
    (
      '타이틀',
      '매장정보',
      '영수증번호',
      '테이블명',
      '인원',
      '메뉴',
      '주문자(배달자)',
      '주문번호',
      '주문번호(상단)',
      '주문번호(하단)'
    ),
    (
      '타이틀',
      '매장정보',
      '영수증번호',
      '테이블',
      '인원',
      '메뉴',
      '주문자(배달자)',
      '주문번호',
      '',
      ''
    )
  );
  arrPrnOptionList_hggCaption: array [0 .. 1] of String = (
    '매장정보(좌석제 전용)',
    '영수증하단문구(좌석제 전용)'
  );

  arrPrnOptionList_KitCation: array [0 .. 1] of array [0 .. 9] of string = (
    (
      '타이틀',
      '테이블명',
      'POS번호',
      '출력시간',
      '인원',
      '주문자(배달자)',
      '주문번호',
      '영수번호(선불)',
      '주문번호(하단)',
      '주문번호(상단)'
    ),
    (
      '타이틀',
      '테이블/참고',
      'POS번호',
      '출력시간',
      '인원',
      '주문자(배달자)',
      '메뉴',
      '주문번호',
      '영수번호 (선불)',
      ''
    )
  );

  arrRecType: array [0 .. 4] of String = (
    '영수증 무조건 발행',
    '영수증 질의 후 발행',
    '영수증 발행안함',
    '영수증 현금결제시 발행안함',
    '영수증 현금결제만 발행'
  );

  arrKitExtType: array [0 .. 2] of String = (
    '확대폰트 2 X 2',
    '확대폰트 2 X 1',
    '확대폰트 1 X 2'
  );

  arrYN: array [0 .. 1] of String = (
    '사용',
    '사용안함'
  );

  arrDataSearch_Type: array [0 .. 1] of String = (
    '상품명/코드로 검색',
    '판매금액으로 검색'
  );
  {
    arrDataSearch_Option: array of String = (
    );
    arrDataSearch_Rows: array of String = (
    '10개씩 표시',
    '20개씩 표시',
    '30개씩 표시'
    );
  }

implementation

{%CLASSGROUP 'Vcl.Controls.TControl'}

uses ufmList, fmENV1_1, uMain, ufmKeypad, ufmPopup, ufmBG, fmSYS1_1, fmSYS1_3;
{$R *.dfm}

function TDM.GetList(Title: String; arrList: array of String): TResult_IS;
var
  i: Word;
  li: TListItem;
begin
  //
  fmList := TfmList.Create(Form_AirManager);

  try
    with fmList do
    begin
      for i := Low(arrList) to High(arrList) do
      begin
        li := ListView_Body.Items.Add;
        li.Caption := arrList[i];
        li.SubItems.Add(IntToStr(i));
      end;

      if Title = '' then
        Label_title.Caption := '선택해주세요.'
      else
        Label_title.Caption := Title;

      ShowModal;

      if ModalResult = mrOK then
      begin
        with ListView_Body.Selected do
        begin
          GetList.Result_Str := Caption;
          GetList.Result_int := StrToIntDef(SubItems.Strings[0], 0);
        end;
      end
      else
      begin
        GetList.Result_Str := '취소';
        GetList.Result_int := -99;
      end;
    end;

  finally
    fmList.Free;
  end;
end;

function TDM.GetLogin(Title: String): TResult_IS;
begin
  //
  fmKeypad := TfmKeypad.Create(Self);
  try
    with fmKeypad do
    begin
      if Title <> '' then
        Frame_ENV_Edit1.Label_Key.Caption := Title;

      Frame_ENV_Edit1.Edit_Value.PasswordChar := '●';
      ShowModal;
      if Tag = 0 then
      begin
        Result.Result_int := Tag;
        Result.Result_Str := Hint;
      end
      else
      begin
        Result.Result_int := Tag;
        Result.Result_Str := '성공';
      end;
    end;
  finally

    FreeAndNil(fmKeypad);
  end;

end;

function TDM.GetOpen(iType: Integer): TResult_IS;
begin
  //
  case iType of
    0:
      begin
        OpenDialog.Title := '파일 선택';
        OpenDialog.Options := [];
      end;
    1: // 미디어 파일 (mp4, avi 등)
      begin
        OpenDialog.Title := '미디어 파일 선택';
        OpenDialog.Options := [];
        with OpenDialog.FileTypes.Add do
        begin
          DisplayName := '미디어 파일';
          FileMask := '*.mp4;*.avi;*.wmv;*.mkv';
        end;
      end;
  end;
  if OpenDialog.Execute then
  begin
    Result.Result_int := 1;
    Result.Result_Str := OpenDialog.FileName;
  end
  else
  begin
    Result.Result_int := 0;
    Result.Result_Str := '폴더 선택안함';
  end;

end;

function TDM.GetPopup(iType: Byte; sMsg: String): TResult_IS;
begin
  Result := GetPopup(iType, '안 내', sMsg, '');
end;

function TDM.GetPopup(sMsg: String): TResult_IS;
begin
  Result := GetPopup(0, '', sMsg, '');
end;

function TDM.GetPopup(iType: Byte; Title, sMsg, imageName: String): TResult_IS;
begin
  { iType
    - 0:  확인만 표시
    - 1: 예, 아니오 표시

    응답
    - 0 : 아니요
    - 1 : 예, 확인
  }
  SetLog(Title + ' : ' + sMsg);
  sMsg := StringReplace(sMsg, '||', #13#10, [rfReplaceALL]);
  fmPopup := TfmPopup.Create(Self);
  with fmPopup do
  begin
    Tag := iType;
    Panel_Header.Caption := Title;

    if Trim(imageName) = '' then
    begin
      Label_Msg.Caption := sMsg;
    end
    else
    begin
      Label_Msg.Visible := False;
      Image_Msg.Align := alClient;
    end;

    ShowModal;
    Result.Result_int := Tag;
    Result.Result_Str := Hint;

    Free;
  end;

  if iType <> 0 then
    SetLog(IntToStr(Result.Result_int) + ' : ' + Result.Result_Str);
end;

function TDM.SetFrameCheckBOX(bYN: Boolean; FrameCheckBox: TFrame_ENV_CHECKBOX): TResult_IS;
var
  sImgName: String;
begin
  with FrameCheckBox do
  begin
    Tag := StrToIntDef(BoolToStr(bYN), 0);
    case Tag of
      0:
        begin
          sImgName := 'Check_OFF.png';
        end;
    else
      begin
        sImgName := 'Check_ON.png';
      end;
    end;
    Image_Check.Picture.LoadFromFile(ProgramPath + IMG_PATH + sImgName);
  end;
end;

function TDM.Image_CheckBOX(iTag: Integer; FrameCheckBox: TFrame_ENV_CHECKBOX): TResult_IS;
var
  iImgTag: Integer;
  sImgName: String;
begin
  case iTag of
    0:
      begin
        sImgName := 'Check_ON.png';
        iImgTag := 1;
      end;
  else
    begin
      sImgName := 'Check_OFF.png';
      iImgTag := 0;
    end;
  end;

  if NOT FileExists(ProgramPath + IMG_PATH + sImgName) then
  begin
    Result.Result_int := -1;
    Result.Result_Str := sImgName + ' 이미지를 찾을 수 없음';
    Exit;
  end;
  with FrameCheckBox do
  begin
    Image_Check.Picture.LoadFromFile(ProgramPath + IMG_PATH + sImgName);
    Tag := iImgTag;
  end;
end;

procedure TDM.iniInfo(iType: Integer; siniName: String);
const
  Airpos_Seaction = 'AIRPOS';
  Server_Seaction = 'POS';
  Control_Seaction = 'CONTROL';
var
  ini: TiniFile;
  i, j: Integer;
  sStr: String;
begin
  // iType
  {
    0 : Read
    1 : Write
  }
  if (FileExists(siniName) = False) AND (siniName <> '.\AirControl.ini') then
  begin
    if POS('AIRPOS.ini', siniName) > 0 then
    begin
      GetPopup(0, '파일확인요망', siniName + '을 찾을수 없습니다. 푸드카페를 설치 후 진행해주세요.', '');
      Application.Terminate;
      Exit;
    end;
  end;
  ini := TiniFile.Create(siniName);
  try
    with ini do
    begin
      if POS('AIRPOS.ini', siniName) > 0 then
      begin
        case iType of
          0:
            begin
              StoreName := ReadString(Airpos_Seaction, 'GMZNM', StoreName);
              StoreOwner := ReadString(Airpos_Seaction, 'GBoss', StoreOwner);
              StoreType := ReadString(Airpos_Seaction, 'Upjong', StoreType);
              StoreSeq := ReadString(Airpos_Seaction, 'GRegNo', StoreSeq);
              StoreTel := ReadString(Airpos_Seaction, 'GTelNO', StoreTel);
              StoreAddr1 := ReadString(Airpos_Seaction, 'gAddr1', StoreAddr1);
              StoreAddr2 := ReadString(Airpos_Seaction, 'gAddr2', StoreAddr2);

              Posno := ReadInteger(Airpos_Seaction, 'PosNo', Posno);
              HostIP := ReadString(Airpos_Seaction, 'HostIP', HostIP);
              for i := Low(arrkitCommIP) to High(arrkitCommIP) do
                arrkitCommIP[i] := ReadString(Airpos_Seaction, 'kitCommIP' + IntToStr(i), '');

              optCloseSale := ReadBool(Airpos_Seaction, 'optCloseSale', optCloseSale);
              useSale24 := ReadBool(Airpos_Seaction, 'useSale24', useSale24);
              TimeOrigin := ReadString(Airpos_Seaction, 'TimeOrigin', TimeOrigin);
              useAdvance := ReadBool(Airpos_Seaction, 'useAdvance', useAdvance);
              useTimeSale := ReadBool(Airpos_Seaction, 'useTimeSale', useTimeSale);
              TimeSaleStaticLock := ReadBool(Airpos_Seaction, 'TimeSaleStaticLock', TimeSaleStaticLock);
              TimeAutoLockerLayer := ReadBool(Airpos_Seaction, 'TimeAutoLockerLayer', TimeAutoLockerLayer);
              TimeTableTag := ReadBool(Airpos_Seaction, 'TimeTableTag', TimeTableTag);
              TimeSaleNoAdvance := ReadBool(Airpos_Seaction, 'TimeSaleNoAdvance', TimeSaleNoAdvance);
              useTimeOverChg := ReadBool(Airpos_Seaction, 'useTimeOverChg', useTimeOverChg);
              useTimeChange := ReadBool(Airpos_Seaction, 'useTimeChange', useTimeChange);

              FoodCourt := ReadBool(Airpos_Seaction, 'FoodCourt', False);
              TableSizeGB := ReadInteger(Airpos_Seaction, 'TableSizeGB', 1);

              GMZNO := ReadString(Airpos_Seaction, 'GMZNO', GMZNO);
              useAutoDown := ReadInteger(Airpos_Seaction, 'useAutoDown', 0);
              useNOTStock := ReadBool(Airpos_Seaction, 'useNOTStock', useNOTStock);
              CloseNoUpdate := ReadBool(Airpos_Seaction, 'CloseNoUpdate', CloseNoUpdate);
              NotSaleSend := ReadBool(Airpos_Seaction, 'NotSaleSend', NotSaleSend);

              QuesAppr := ReadBool(Airpos_Seaction, 'QuesAppr', QuesAppr);
              useOrdCashRecp := ReadBool(Airpos_Seaction, 'useOrdCashRecp', useOrdCashRecp);
              useIDSave := ReadBool(Airpos_Seaction, 'useIDSave', useIDSave);

              for i := Low(arrPrnOptionList) to High(arrPrnOptionList) do
              begin
                with arrPrnOptionList[i] do
                begin
                  slMemo := TStringList.Create;
                  slMemo.Clear;
                  case i of
                    0: // 영수증
                      begin
                        SetLength(BS_Prn, 10);
                        SetLength(BS_Ext, 8);
                        iTop_Len := ReadInteger(Airpos_Seaction, 'RecTopCnt', iTop_Len);
                        iBot_Len := ReadInteger(Airpos_Seaction, 'RecBotCnt', iBot_Len);
                        iPrnCnt := ReadInteger(Airpos_Seaction, 'RecpCnt', iPrnCnt);

                        for j := Low(BS_Prn) to High(BS_Prn) do
                        begin
                          BS_Prn[j].Result_Str := arrPrnOptionList_RecCation[0, j];
                          case j of
                            0 .. 7:
                              begin
                                BS_Prn[j].Result_Bool := ReadBool(Airpos_Seaction, 'recPrn' + IntToStr(j + 1), True);

                              end;
                            8:
                              begin
                                BS_Prn[j].Result_Bool := ReadBool(Airpos_Seaction, 'RecOrdNoUpPrn', True);
                              end;
                            9:
                              begin
                                BS_Prn[j].Result_Bool := ReadBool(Airpos_Seaction, 'RecOrdNoDownPrn', True);
                              end;
                          end;
                        end;

                        for j := Low(BS_Ext) to High(BS_Ext) do
                        begin
                          BS_Ext[j].Result_Bool := ReadBool(Airpos_Seaction, 'RecFnt' + IntToStr(j + 1), True);
                          BS_Ext[j].Result_Str := arrPrnOptionList_RecCation[1, j];

                        end;

                        for j := 1 to 10 do
                        begin
                          sStr := ReadString(Airpos_Seaction, 'r_Bigo' + IntToStr(j), '');
                          if Trim(sStr) <> '' then
                            slMemo.Add(sStr);
                        end;

                      end;
                    1: // 고객주문서
                      begin
                        SetLength(BS_Prn, 2);
                        SetLength(BS_Ext, 0);

                        BS_Prn[0].Result_Bool := ReadBool(Airpos_Seaction, 'ggprnnogmz', False);
                        BS_Prn[1].Result_Bool := ReadBool(Airpos_Seaction, 'ggRecBigo', False);

                        for j := Low(BS_Prn) to High(BS_Prn) do
                          BS_Prn[j].Result_Str := arrPrnOptionList_hggCaption[j];

                        iTop_Len := ReadInteger(Airpos_Seaction, 'hggTopCnt', iTop_Len);
                        iBot_Len := ReadInteger(Airpos_Seaction, 'hggBotCnt', iBot_Len);
                        iPrnCnt := 1;

                      end;
                    2: // 주방주문서
                      begin
                        SetLength(BS_Prn, 10);
                        SetLength(BS_Ext, 9);

                        iTop_Len := ReadInteger(Airpos_Seaction, 'kitTopCnt', iTop_Len);
                        iBot_Len := ReadInteger(Airpos_Seaction, 'kitBotCnt', iBot_Len);
                        iPrnCnt := ReadInteger(Airpos_Seaction, 'kitPrtCnt', iPrnCnt);

                        for j := Low(BS_Prn) to High(BS_Prn) do
                        begin
                          BS_Prn[j].Result_Str := arrPrnOptionList_KitCation[0, j];
                          case j of
                            0 .. 5, 9:
                              begin
                                BS_Prn[j].Result_Bool := ReadBool(Airpos_Seaction, 'ordPrn' + IntToStr(j + 1), True);
                              end;
                            6:
                              begin
                                BS_Prn[j].Result_Bool := ReadBool(Airpos_Seaction, 'KitOrdNoPrn', True);
                              end;
                            7:
                              begin
                                BS_Prn[j].Result_Bool := ReadBool(Airpos_Seaction, 'kitOrdNoUpPrn', True);
                              end;
                            8:
                              begin
                                BS_Prn[j].Result_Bool := ReadBool(Airpos_Seaction, 'kitOrdNoDownPrn', True);
                              end;
                          end;
                        end;

                        for j := Low(BS_Ext) to High(BS_Ext) do
                        begin
                          BS_Ext[j].Result_Str := arrPrnOptionList_KitCation[1, j];
                          case j of
                            0 .. 7:
                              begin
                                BS_Ext[j].Result_Bool := ReadBool(Airpos_Seaction, 'OrdFnt' + IntToStr(j + 1), True);
                              end;
                            8:
                              begin
                                BS_Ext[j].Result_Bool := ReadBool(Airpos_Seaction, 'OrdFnt10', True);
                              end;
                          end;
                        end;

                        for j := 1 to 4 do
                        begin
                          sStr := ReadString(Airpos_Seaction, 'kit_Bigo' + IntToStr(j), '');
                          if Trim(sStr) <> '' then
                            slMemo.Add(sStr);
                        end;
                      end;
                  end;

                  sTitle := ReadString(Airpos_Seaction, 'PrnTitle' + IntToStr(i + 1), sTitle);

                end;
              end;

              recCardSlip := ReadBool(Airpos_Seaction, 'recCardSlip', recCardSlip);
              BCPaper := ReadBool(Airpos_Seaction, 'BCPaper', BCPaper);

              // COM 1~4
              for i := Low(Port_List) to High(Port_List) do
              begin
                with Port_List[i] do
                begin
                  iPort := i;
                  iType := ReadInteger(Airpos_Seaction, 'Port' + IntToStr(i), 0);
                  iKit := ReadInteger(Airpos_Seaction, 'KitPrt' + IntToStr(i), 0);
                  iKit_Spc := ReadInteger(Airpos_Seaction, 'kitCom' + IntToStr(i) + 'sel', 0);
                end;
              end;

              // 확장포트
              for i := Low(ExtPort_List) to High(ExtPort_List) do
              begin
                with ExtPort_List[i] do
                begin
                  iPort := ReadInteger(Airpos_Seaction, 'Extport' + IntToStr(i), 0);
                  iType := ReadInteger(Airpos_Seaction, 'ExtKitPrt' + IntToStr(i), 0);
                  iKit := 0;
                  iKit_Spc := ReadInteger(Airpos_Seaction, 'kitexCom' + IntToStr(i) + 'sel', 0);
                  iMachineType := ReadInteger(Airpos_Seaction, 'ExtKitPrnType' + IntToStr(i), 0);
                end;
              end;

              RecPrnType := ReadInteger(Airpos_Seaction, 'RecPrnType', 0);
              KitPrnType := ReadInteger(Airpos_Seaction, 'KitPrnType', 0);
              KitDriverPrint := ReadBool(Airpos_Seaction, 'KitDriverPrint', KitDriverPrint);

              ReceiptPrn := ReadInteger(Airpos_Seaction, 'ReceiptPrn', ReceiptPrn);
              KitFontSize := ReadInteger(Airpos_Seaction, 'KitFontSize', KitFontSize);
              UseggPrn := ReadBool(Airpos_Seaction, 'UseggPrn', UseggPrn);

              NewDelv := ReadBool(Airpos_Seaction, 'NewDelv', NewDelv);
              vDelvPort := ReadString(Airpos_Seaction, 'vDelvPort', vDelvPort);
              vDelvRec := ReadBool(Airpos_Seaction, 'vDelvRec', vDelvRec);
              vDelvKitNumber := ReadInteger(Airpos_Seaction, 'vDelvKitNumber', vDelvKitNumber);

              //

              VANGB := ReadInteger(Airpos_Seaction, 'VANGB', 0);
              TermNo := ReadString(Airpos_Seaction, 'TermNo', TermNo);
              useSecuAgent := ReadBool(Airpos_Seaction, 'useSecuAgent', useSecuAgent);
              useSecuAgentport := ReadInteger(Airpos_Seaction, 'useSecuAgentport', 0);

              useSecuRefAppr := ReadBool(Airpos_Seaction, 'useSecuRefAppr', useSecuRefAppr);
              useSecuRefPort := ReadInteger(Airpos_Seaction, 'useSecuRefPort', 0);

              useSignPad := ReadBool(Airpos_Seaction, 'useSignPad', useSignPad);
              SignPadNo := ReadInteger(Airpos_Seaction, 'SignPadNo', 0);

              ordFuncType := ReadBool(Airpos_Seaction, 'ordFuncType', ordFuncType);
              arrLetsGoordID[1] := ReadInteger(Airpos_Seaction, 'LetsGoordID1', arrLetsGoordID[1]);

              useDualMonitor := ReadBool(Airpos_Seaction, 'useDualMonitor', useDualMonitor);
              DualDisplayText := ReadString(Airpos_Seaction, 'DualDisplayText', DualDisplayText);
              for i := Low(DualDisplayFile) to High(DualDisplayFile) do
              begin
                DualDisplayFile[i] := ReadString(Airpos_Seaction, 'DualDisplayFile' + IntToStr(i), '');
              end;

            end;
          1:
            begin
              WriteString(Airpos_Seaction, 'GMZNM', StoreName);
              WriteString(Airpos_Seaction, 'GBoss', StoreOwner);
              WriteString(Airpos_Seaction, 'Upjong', StoreType);
              WriteString(Airpos_Seaction, 'GRegNo', StoreSeq);
              WriteString(Airpos_Seaction, 'GTelNO', StoreTel);
              WriteString(Airpos_Seaction, 'gAddr1', StoreAddr1);
              WriteString(Airpos_Seaction, 'gAddr2', StoreAddr2);

              WriteInteger(Airpos_Seaction, 'PosNo', Posno);
              WriteString(Airpos_Seaction, 'HostIP', HostIP);

              for i := Low(arrkitCommIP) to High(arrkitCommIP) do
              begin
                WriteString(Airpos_Seaction, 'kitCommIP' + IntToStr(i), arrkitCommIP[i]);
              end;
              if arrkitCommIP[1] <> '' then
                WriteBool(Airpos_Seaction, 'NotCommSvr', False)
              else
                WriteBool(Airpos_Seaction, 'NotCommSvr', True);

              WriteBool(Airpos_Seaction, 'optCloseSale', optCloseSale);
              WriteBool(Airpos_Seaction, 'useSale24', useSale24);
              WriteString(Airpos_Seaction, 'TimeOrigin', Copy(TimeOrigin, 1, 5));
              WriteBool(Airpos_Seaction, 'useAdvance', useAdvance);
              WriteBool(Airpos_Seaction, 'useTimeSale', useTimeSale);
              WriteBool(Airpos_Seaction, 'TimeSaleStaticLock', TimeSaleStaticLock);
              WriteBool(Airpos_Seaction, 'TimeAutoLockerLayer', TimeAutoLockerLayer);
              WriteBool(Airpos_Seaction, 'TimeTableTag', TimeTableTag);
              WriteBool(Airpos_Seaction, 'TimeSaleNoAdvance', TimeSaleNoAdvance);
              WriteBool(Airpos_Seaction, 'useTimeOverChg', useTimeOverChg);
              WriteBool(Airpos_Seaction, 'useTimeChange', useTimeChange);

              WriteString(Airpos_Seaction, 'GMZNO', GMZNO);
              WriteInteger(Airpos_Seaction, 'useAutoDown', useAutoDown);
              WriteBool(Airpos_Seaction, 'useNOTStock', useNOTStock);
              WriteBool(Airpos_Seaction, 'CloseNoUpdate', CloseNoUpdate);
              WriteBool(Airpos_Seaction, 'NotSaleSend', NotSaleSend);

              WriteBool(Airpos_Seaction, 'QuesAppr', QuesAppr);
              WriteBool(Airpos_Seaction, 'useOrdCashRecp', useOrdCashRecp);
              WriteBool(Airpos_Seaction, 'useIDSave', useIDSave);

              for i := Low(arrPrnOptionList) to High(arrPrnOptionList) do
              begin
                with arrPrnOptionList[i] do
                begin
                  case i of
                    0: // 영수증
                      begin
                        WriteInteger(Airpos_Seaction, 'RecTopCnt', iTop_Len);
                        WriteInteger(Airpos_Seaction, 'RecBotCnt', iBot_Len);
                        WriteInteger(Airpos_Seaction, 'RecpCnt', iPrnCnt);
                        WriteBool(Airpos_Seaction, 'UseKitPrn', iPrnCnt > 0);

                        for j := Low(BS_Prn) to High(BS_Prn) do
                        begin
                          case j of
                            0 .. 7:
                              begin
                                WriteBool(Airpos_Seaction, 'recPrn' + IntToStr(j + 1), BS_Prn[j].Result_Bool);
                              end;
                            8:
                              begin
                                WriteBool(Airpos_Seaction, 'RecOrdNoUpPrn', BS_Prn[j].Result_Bool);
                              end;
                            9:
                              begin
                                WriteBool(Airpos_Seaction, 'RecOrdNoDownPrn', BS_Prn[j].Result_Bool);
                              end;
                          end;
                        end;

                        for j := Low(BS_Ext) to High(BS_Ext) do
                        begin
                          WriteBool(Airpos_Seaction, 'RecFnt' + IntToStr(j + 1), BS_Ext[j].Result_Bool);
                        end;

                        for j := 1 to 10 do
                        begin
                          if (j) > slMemo.Count then
                            WriteString(Airpos_Seaction, 'r_Bigo' + IntToStr(j), '')
                          else
                            WriteString(Airpos_Seaction, 'r_Bigo' + IntToStr(j), slMemo[j - 1]);
                        end;

                      end;
                    1: // 고객주문서
                      begin
                        WriteInteger(Airpos_Seaction, 'hggTopCnt', iTop_Len);
                        WriteInteger(Airpos_Seaction, 'hggBotCnt', iBot_Len);

                        WriteBool(Airpos_Seaction, 'ggprnnogmz', BS_Prn[0].Result_Bool);
                        WriteBool(Airpos_Seaction, 'ggRecBigo', BS_Prn[1].Result_Bool);
                      end;
                    2: // 주방주문서
                      begin
                        WriteInteger(Airpos_Seaction, 'kitTopCnt', iTop_Len);
                        WriteInteger(Airpos_Seaction, 'kitBotCnt', iBot_Len);
                        WriteInteger(Airpos_Seaction, 'kitPrtCnt', iPrnCnt);
                        WriteBool(Airpos_Seaction, 'UseKitPrn', iPrnCnt > 0);

                        for j := Low(BS_Prn) to High(BS_Prn) do
                        begin
                          case j of
                            0 .. 5, 9:
                              begin
                                WriteBool(Airpos_Seaction, 'ordPrn' + IntToStr(j + 1), BS_Prn[j].Result_Bool);
                              end;
                            6:
                              begin
                                WriteBool(Airpos_Seaction, 'KitOrdNoPrn', BS_Prn[j].Result_Bool);
                              end;
                            7:
                              begin
                                WriteBool(Airpos_Seaction, 'kitOrdNoUpPrn', BS_Prn[j].Result_Bool);
                              end;
                            8:
                              begin
                                WriteBool(Airpos_Seaction, 'kitOrdNoDownPrn', BS_Prn[j].Result_Bool);
                              end;
                          end;
                        end;

                        for j := Low(BS_Ext) to High(BS_Ext) do
                        begin
                          case j of
                            0 .. 7:
                              begin
                                WriteBool(Airpos_Seaction, 'OrdFnt' + IntToStr(j + 1), BS_Ext[j].Result_Bool);
                              end;
                            8:
                              begin
                                WriteBool(Airpos_Seaction, 'OrdFnt10', BS_Ext[j].Result_Bool);
                              end;
                          end;
                        end;

                        for j := 1 to 4 do
                        begin
                          if (j) > slMemo.Count then
                            WriteString(Airpos_Seaction, 'kit_Bigo' + IntToStr(j), '')
                          else
                            WriteString(Airpos_Seaction, 'kit_Bigo' + IntToStr(j), slMemo[j - 1]);
                        end;
                      end;
                  end;
                  WriteString(Airpos_Seaction, 'PrnTitle' + IntToStr(i + 1), sTitle);
                end;
              end;

              WriteBool(Airpos_Seaction, 'recCardSlip', recCardSlip);
              WriteBool(Airpos_Seaction, 'BCPaper', BCPaper);

              // 기본포트 (COM 1~4)
              for i := Low(Port_List) to High(Port_List) do
              begin
                with Port_List[i] do
                begin
                  case iType of
                    0:
                      begin
                        iType := 0;
                        iKit := 0;
                      end;
                    1 .. 10:
                      begin
                        iKit := 0;
                      end;
                    11 .. 16:
                      begin
                        iKit := iType - 10;
                        iType := 0;
                      end;
                  end;
                  WriteInteger(Airpos_Seaction, 'Port' + IntToStr(i), iType);
                  WriteInteger(Airpos_Seaction, 'KitPrt' + IntToStr(i), iKit);
                  WriteInteger(Airpos_Seaction, 'kitCom' + IntToStr(i) + 'sel', iKit_Spc);
                end;
              end;

              // 확장포트
              for i := Low(ExtPort_List) to High(ExtPort_List) do
              begin
                with ExtPort_List[i] do
                begin
                  WriteInteger(Airpos_Seaction, 'Extport' + IntToStr(i), iPort);
                  case iType of
                    0:
                      begin
                        iType := 0;
                      end;
                    1 .. 16:
                      begin
                      end;
                  end;
                  WriteInteger(Airpos_Seaction, 'ExtKitPrt' + IntToStr(i), iType);
                  WriteInteger(Airpos_Seaction, 'kitexCom' + IntToStr(i) + 'sel', iKit_Spc);
                  WriteInteger(Airpos_Seaction, 'ExtKitPrnType' + IntToStr(i), iMachineType);
                end;
              end;

              WriteInteger(Airpos_Seaction, 'ReceiptPrn', ReceiptPrn);
              WriteInteger(Airpos_Seaction, 'KitFontSize', KitFontSize);
              WriteBool(Airpos_Seaction, 'UseggPrn', UseggPrn);

              WriteBool(Airpos_Seaction, 'NewDelv', NewDelv);
              WriteString(Airpos_Seaction, 'vDelvPort', vDelvPort);
              WriteBool(Airpos_Seaction, 'vDelvRec', vDelvRec);
              WriteInteger(Airpos_Seaction, 'vDelvKitNumber', vDelvKitNumber);

              WriteInteger(Airpos_Seaction, 'RecPrnType', RecPrnType);
              WriteInteger(Airpos_Seaction, 'KitPrnType', KitPrnType);
              WriteBool(Airpos_Seaction, 'KitDriverPrint', KitDriverPrint);

              //

              WriteInteger(Airpos_Seaction, 'VANGB', VANGB);
              WriteString(Airpos_Seaction, 'TermNo', TermNo);
              WriteBool(Airpos_Seaction, 'useSecuAgent', useSecuAgent);
              WriteInteger(Airpos_Seaction, 'useSecuAgentport', useSecuAgentport);

              WriteBool(Airpos_Seaction, 'useSecuRefAppr', useSecuRefAppr);
              WriteInteger(Airpos_Seaction, 'useSecuRefPort', useSecuRefPort);

              WriteBool(Airpos_Seaction, 'useSignPad', useSignPad);
              WriteInteger(Airpos_Seaction, 'SignPadNo', SignPadNo);

              WriteBool(Airpos_Seaction, 'ordFuncType', ordFuncType);
              WriteInteger(Airpos_Seaction, 'LetsGoordID1', arrLetsGoordID[1]);
              WriteBool(Airpos_Seaction, 'useDualMonitor', useDualMonitor);
              WriteString(Airpos_Seaction, 'DualDisplayText', DualDisplayText);
              for i := Low(DualDisplayFile) to High(DualDisplayFile) do
              begin
                WriteString(Airpos_Seaction, 'DualDisplayFile' + IntToStr(i), DualDisplayFile[i]);
              end;
            end;
        end;
      end
      else if POS('Servers.ini', siniName) > 0 then
      begin
        case iType of
          0:
            begin
              DBPath := ReadString(Server_Seaction, 'DBPATH', DBPath);
            end;
          1:
            begin
              WriteString(Server_Seaction, 'DBPATH', DBPath);
              WriteString(Server_Seaction, 'Address', HostIP);
            end;
        end;
      end
      else if POS('AirControl.ini', siniName) > 0 then
      begin
        case iType of
          0:
            begin
              AC_bYN := ReadBool(Control_Seaction, 'ServerYN', AC_bYN);
              if AC_bYN = False then
              begin
                AC_sHostIP := ReadString(Control_Seaction, 'HostIP', AC_sHostIP);
                AC_iPort := ReadInteger(Control_Seaction, 'Port', AC_iPort);
                AC_iEXEType := ReadInteger(Control_Seaction, 'EXEType', AC_iEXEType);
              end;
            end;
          1:
            begin
              WriteBool(Control_Seaction, 'ServerYN', AC_bYN);
              if AC_bYN then
              begin
                AC_sHostIP := '';
                AC_iEXEType := 0;
              end;
              WriteString(Control_Seaction, 'HostIP', AC_sHostIP);
              WriteInteger(Control_Seaction, 'Port', AC_iPort);
              WriteInteger(Control_Seaction, 'Posno', Posno);
              WriteInteger(Control_Seaction, 'EXEType', AC_iEXEType);
            end;
        end;
      end;
    end;
  finally
    ini.Free;
  end;

end;

function TDM.IPValueCheck(sIP_Address: String): Boolean;
var
  RegIPAddress: String;
begin
  //
  RegIPAddress := '\b' + //
    '(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.' + '(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.' + '(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.' +
    '(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\b';

  Result := TRegEx.IsMatch(sIP_Address, RegIPAddress);
end;

function TDM.JsonParserString(JsonVal: String): String;
begin
  Result := StringReplace(JsonVal, '"', '', [rfReplaceALL]);
end;

function TDM.KorCheck(sText: String): Boolean;
const
  {
    True : 한글 존재
    False : 한글 없음
  }

  KOR_Regex = '.*[ㄱ-ㅎㅏ-ㅣ가?]+.*';
begin
  Result := TRegEx.IsMatch(sText, KOR_Regex);
end;

function TDM.LabelFontSize(SetLabel_Control: TLabel): Byte;
var
  Rect_Test: TRect;

  bCHk, bGet: Boolean;
  sText: String;
  i, j: Byte;
begin
  if (SetLabel_Control = nil) OR (NOT(SetLabel_Control is TLabel)) then
  begin
    Result := 10;
    Exit;
  end;

  bGet := False;
  bCHk := False;
  i := 16;
  sText := SetLabel_Control.Caption;

  Rect_Test := Default (TRect);
  with Rect_Test do
  begin
    Right := SetLabel_Control.Width;
    Bottom := SetLabel_Control.Height;

    j := i;
    repeat
      with SetLabel_Control do
      begin
        Canvas.Font.Size := j;
        Canvas.TextRect(Rect_Test, sText, [tfCalcRect]);

        if ((Rect_Test.Right - Rect_Test.Left) < Width) AND ((Rect_Test.Bottom - Rect_Test.Top) < Height) then
        begin
          bGet := True;
        end
        else
        begin
          if ((Rect_Test.Right - Rect_Test.Left) < Width) OR ((Rect_Test.Bottom - Rect_Test.Top) < Height) then
            bCHk := True
          else
            bCHk := False;

          if bCHk then
            Dec(j)
          else
            j := j - 2;
        end;

        if j <= 4 then
        begin
          j := 4;
          bGet := True;
        end;
      end;
    until bGet;
  end;
  Result := j;
end;

function TDM.Label_YN(bYN: Boolean; FrameYN: TFrame_ENV_YN): TResult_IS;
var
  iInt: Integer;
begin
  with FrameYN do
  begin
    // 왼쪽 클릭
    if bYN then
    begin
      iInt := 1;

      with Label_Y do
      begin
        Font.Color := cSelLabel_Font;
        Color := cSelLabel_BG;
      end;

      with Label_N do
      begin
        Font.Color := cLabel_Font;
        Color := cLabel_BG;
      end;
    end

    // 오른쪽 클릭
    else
    begin
      iInt := 0;
      with Label_Y do
      begin
        Font.Color := cLabel_Font;
        Color := cLabel_BG;
      end;

      with Label_N do
      begin
        Font.Color := cSelLabel_Font;
        Color := cSelLabel_BG;
      end;
    end;
    Tag := iInt;
  end;
end;

procedure TDM.OpenExplorer(sPath: String);
begin
  ShellExecute(Application.Handle, nil, 'explorer.exe', PWideChar(sPath), nil, SW_NORMAL);
end;

procedure TDM.Recv_Msg(var MSG: TWMCopyData);
const
  sLF = #10;
var
  RecvText, RecvText_Backup: String;

  json_msg, json_Info: TJsonObject;
  json_list: TJSONArray;

  ConnCnt, totalCnt, LastUpdate: String;
  i: Integer;

begin
  // Msg Sample
  try
    bWinMsg_Recv := True;
    RecvText := PChar(MSG.CopyDataStruct.lpData);
    RecvText_Backup := RecvText;

    SetLog('받은 메세지 : ' + RecvText);
  except
    On E: Exception do
      SetLog('윈도우 메세지 확인중 오류 : ' + E.Message);
  end;

  try

    try
      json_msg := TJsonObject.Create;
      json_Info := TJsonObject.Create;
      json_msg := TJsonObject.ParseJSONValue(RecvText) as TJsonObject;

      if json_msg.GetValue<string>('MsgType') = 'Set' then
      begin
        SetLength(arrPos_Info, 0);
        with json_msg do
        begin
          ConnCnt := GetValue('ConnCnt').ToString;
          totalCnt := GetValue('TotalCnt').ToString;
          LastUpdate := GetValue('LastUpdate').ToString;

          SetLog('총/연결된 장치 : ' + totalCnt + '/' + ConnCnt);
          if totalCnt = '0' then
          begin
            SetLog('연결된 장치 없음');
            Exit;
          end
          else
          begin
            json_list := GetValue('PosList') as TJSONArray;
            SetLength(arrPos_Info, json_list.Count);

            for i := Low(arrPos_Info) to High(arrPos_Info) do
            begin
              json_Info := json_list.Items[i] as TJsonObject;
              with json_Info, arrPos_Info[i] do
              begin
                iSEQ := StrToIntDef(JsonParserString(GetValue('PosNo').ToString), 0);
                bConn := JsonParserString(GetValue('Connecting').ToString) <> '0';
                shost := JsonParserString(GetValue('PosIP').ToString);
                sName := JsonParserString(GetValue('PosName').ToString);
                sAppName := JsonParserString(GetValue('PosAppName').ToString);

                SetLog(IntToStr(i + 1) + ' 번째 장치정보' + json_Info.ToString);
              end;

            end;
          end;
        end;
      end
      else if json_msg.GetValue<string>('MsgType') = 'Save' then
      begin
        json_Info := TJsonObject.ParseJSONValue(json_msg.GetValue<string>('Options')) as TJsonObject;
        with DID_Opations do
        begin
          DIDViewType := json_Info.GetValue<Integer>('DIDViewType');
          iVoiceType := json_Info.GetValue<Integer>('iVoiceType');
          ReadyOrderUp := json_Info.GetValue<String>('ReadyOrderUp');
          TableUP := json_Info.GetValue<String>('TableUP');
          OrdClearTime := json_Info.GetValue<String>('OrdClearTime');
          ShowMenuList := json_Info.GetValue<Boolean>('ShowMenuList');
          DspSetView := json_Info.GetValue<Boolean>('DspSetView');
          useTopMost := json_Info.GetValue<Boolean>('useTopMost');
          OrdNoneView := json_Info.GetValue<Boolean>('OrdNoneView');
          useAirCall := json_Info.GetValue<Boolean>('useAirCall');
          DelData := json_Info.GetValue<Boolean>('DelData');
          useViewCount := json_Info.GetValue<Boolean>('useViewCount');
          OrdCallFormTimeout := json_Info.GetValue<Integer>('OrdCallFormTimeout');
          ShowDualMonitor := json_Info.GetValue<Boolean>('ShowDualMonitor');
          MediaMute := json_Info.GetValue<Boolean>('MediaMute');
          usePosView := json_Info.GetValue<Boolean>('MediaMute');
          sPosList := json_Info.GetValue<String>('MediaMute');
          Form_SYS1_3.GetOptions(3);
        end;
      end;
    except
      On E: Exception do
      begin
        SetLog('메세지 처리중 오류 : ' + E.Message);
      end;
    end;
  finally
    json_msg.Free;
    AC_Refrush := True;
  end;
end;

procedure TDM.Send_Msg(MSG: String);
var
  DataStruct: CopyDataStruct;
  ExeHandle: THandle;
  RecvText: String;
begin
  bWinMsg_Recv := False;
  ExeHandle := FindWindow(PChar('TForm_SK'), nil);
  if ExeHandle <> 0 then
  begin
    try
      RecvText := '';
      with DataStruct do
      begin
        dwData := 0;
        cbData := (Length(AnsiString(MSG)) * Sizeof(char)) + 1;
        lpData := PChar(MSG);
        SetForegroundWindow(ExeHandle);
        SendMessage(ExeHandle, WM_COPYDATA, Application.Handle, Integer(@DataStruct));
      end;
      SetLog('전달한 메세지 : ' + MSG);
    except
      ON E: Exception do
      begin
        SetLog('메세지송신오류 : ' + E.Message);
        GetPopup(0, '통신 전송 실패', '통신 프로그램과 통신하지 못했습니다.', '');
      end;
    end;
  end
  else
  begin
    GetPopup(0, '통신 연결 실패', '통신 프로그램이 실행되어 있지 않습니다.', '');
  end;
end;

procedure TDM.SetBG(iType: Integer);
begin
  case iType of
    0:
      begin
        if Assigned(fmBG) then
        begin
          FreeAndNil(fmBG);
          fmBG := TfmBG.Create(Self);
        end
        else
          fmBG := TfmBG.Create(Self);
        fmBG.Show;
      end;
    1:
      begin
        FreeAndNil(fmBG);
      end;
  end;
end;

procedure TDM.SetLog(WirteText: String);
var
  F: TextFile;
  ErrorMSG: String;
begin
  try
    if NOT DirectoryExists('.\log') then
      Exit;

    if NOT FileExists(ProgramPath + '.\log\Air_Log' + FormatDateTime('YYYYMMDD', Now) + '.txt') then
    begin
      assignFile(F, ProgramPath + '.\log\Air_Log' + FormatDateTime('YYYYMMDD', Now) + '.txt');
      Rewrite(F);
    end
    else
    begin
      assignFile(F, ProgramPath + '.\log\Air_Log' + FormatDateTime('YYYYMMDD', Now) + '.txt');
      Append(F);
    end;
    WriteLN(F, FormatDateTime('YYYY-MM-DD HH:NN:SS', Now) + ' ' + WirteText);
    CloseFIle(F);
  except
    ON E: Exception do
    begin
      ErrorMSG := E.Message;
    end;
  end;
end;

procedure TDM.SetPngAlphaBlend(img: TPngImage; const Alpha: Byte);
var
  ms, mp: Integer;
  arrScan: pByteArray;
begin
  // png 이미지 투명도 조절
  try
    img.CreateAlpha;

    for ms := 0 to img.Height - 1 do
    begin
      arrScan := img.AlphaScanline[ms];

      for mp := 0 to img.Width - 1 do
      begin
        arrScan[mp] := Alpha;
      end;
    end;
  except
    On E: Exception do
    begin
      SetLog(E.Message);
    end;
  end;

end;

procedure TDM.SetRound(comp: TObject);
begin
  if comp is TForm then
  begin
    with (comp as TForm) do
    begin
      with ClientRect do
      begin
        SetWindowRgn(Handle, CreateRoundRectRgn(Left, Top, Right + 1, Bottom + 1, 35, 35), True);
      end;
    end;
  end
  else if comp is TFrame then
  begin
    with (comp as TFrame) do
    begin
      with ClientRect do
      begin
        SetWindowRgn(Handle, CreateRoundRectRgn(Left, Top, Right + 1, Bottom + 1, 35, 35), True);
      end;
    end;
  end
  else if comp is TPanel then
  begin
    with (comp as TPanel) do
    begin
      with ClientRect do
      begin
        SetWindowRgn(Handle, CreateRoundRectRgn(Left, Top, Right + 1, Bottom + 1, 35, 35), True);
      end;
    end;
  end;
end;

function TDM.SetTRegistry(SetType: Integer; SetName, SetValue: String): TResult_IS;
const
  InsKey = 1;
  DelKey = 0;
begin {
    Reg := TRegistry.Create;
    try
    with Reg do
    begin
    RootKey := HKEY_CURRENT_USER;
    OpenKey('\Software\microsoft\windows\CurrentVersion\Run');
    // 등록
    if SetType = InsKey then
    begin
    end
    // 삭제
    else if SetType = DelKey then
    begin
    end;
    end;
    except
    On E: Exception do
    begin
    end;
    end;
  }
end;

procedure TDM.ShowNotification(sName, sTitle, sMsg: String);
var
  Notice: TNotification;
begin
  if (Win32MajorVersion > 6) or ((Win32MajorVersion = 6) AND (Win32MinorVersion >= 2)) = False then
    Exit;

  Notice := WinNotification.CreateNotification;
  try
    with Notice do
    begin
      Name := sName;
      Title := sTitle;
      AlertBody := sMsg;

      WinNotification.PresentNotification(Notice)
    end;
  finally
    FreeAndNil(Notice);

  end;

end;

procedure TDM.ShowNotification(sName, sMsg: String);
begin
  ShowNotification(sName, '간편관리자 알림', sMsg);
end;

procedure TDM.Timer_DownloadChkTimer(Sender: TObject);
begin
  Timer_DownloadChk.Enabled := False;
  if NOT Assigned(DownloadURL) then
    Exit;

  if DownloadURL.bComplete then
    FileSaveComplete
  else
    Timer_DownloadChk.Enabled := True;
end;

procedure TDM.TouchKeyBoard;
var
  bWin64: BOOL;
  lbRed: LongBool;
begin

  if IsWow64Process(GetCurrentProcess, bWin64) then
  begin
    if bWin64 then
    begin
      if Wow64DisableWow64FsRedirection(lbRed) then
      begin
        ShellExecute(Application.Handle, 'open', PChar('C:\Windows\System32\osk.exe'), nil, nil, SW_SHOWNORMAL);
        if Not Wow64EnableWow64FsRedirection(lbRed) then
          RaiseLastOSError;
      end
      else
        RaiseLastOSError;
    end
    else
      ShellExecute(Application.Handle, 'open', PChar('C:\Windows\System32\osk.exe'), nil, nil, SW_SHOWNORMAL);
  end
  else
  begin
    RaiseLastOSError;
  end;
end;

procedure TDM.WControl_MouseDown(Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
begin
  // 컨트롤 사이즈
end;

function TDM.AnsiFormat(sText: String): AnsiString;
begin
  Result := AnsiFormat(sText, 0);
end;

function TDM.AnsiFormat(sText: String; iCuting: Word): AnsiString;
var
  AnsiText: AnsiString;
begin
  AnsiText := AnsiString(sText);
  if iCuting > 0 then
  begin
    if ByteType(AnsiText, iCuting) = mbLeadByte then
      AnsiText := Copy(AnsiText, 0, iCuting - 1)
    else
      AnsiText := Copy(AnsiText, 0, iCuting);
  end;
  Result := Format('%-' + IntToStr(Length(AnsiText)) + 's', [sText]);
end;

function TDM.ColorHex(sColor: String): String;
var
  Color_Val: TColor;
begin
  Color_Val := StringToColor(sColor);
  Result := IntToStr(Color_Val);
  {
    AnsiStr := AnsiString(sText);
    SetLength(Result, Length(AnsiStr) * 2);
    BinToHex(PAnsiChar(AnsiStr), PChar(result), Length(AnsiStr));
  }
end;

function TDM.AnsiLen(sText: STring): Integer;
begin
  Result := Length(AnsiString(sText));
end;

function TDM.ControlProgram(iType: Byte; sProgramPath: String): TResult_IS;
var
  Shell_Param_1: Byte;
  Process32: TProcessEntry32;
  ExeHandle, KeyHandle: THandle;
  Next: Boolean;
begin
  {
    iType
    0 : 중북관련없이 실행
    - sProgramPath 첫 글자에 따라 파라미터가 달라짐
    0 : SW_HIDE
    1 : SW_SHOWNORMAL, SW_NORMAL
    2 : SW_SHOWMINIMIZED
    3 : SW_SHOWMAXIMIZED, SW_MAXIMIZE
    4 : SW_SHOWNOACTIVATE
    5 : SW_SHOW
    6 : SW_MINIMIZE
    7 : SW_SHOWMINNOACTIVE
    8 : SW_SHOWNA
    9 : SW_RESTORE
    10 : SW_SHOWDEFAULT
    11 : SW_FORCEMINIMIZE

    1 : 프로그램 종료
    2 : 실행유무 확인
  }
  case iType of
    0:
      begin
        try
          Shell_Param_1 := 5;
          ShellExecute(Application.Handle, 'open', PChar(sProgramPath), nil, nil, Shell_Param_1);
          Result.Result_int := 1;
        except
          ON E: Exception do
          begin

          end;
        end;
      end;
    1, 2:
      begin
        Process32.dwSize := Sizeof(TProcessEntry32);
        ExeHandle := CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
        KeyHandle := 0;

        if Process32First(ExeHandle, Process32) then
        begin
          repeat
            // 다음 프로세스가 존재한다면
            Next := Process32Next(ExeHandle, Process32);

            // 같은 프로세스가 있으면 반복 종료
            if AnsiCompareText(Process32.szExeFile, Trim(sProgramPath)) = 0 then
            begin
              KeyHandle := Process32.th32ProcessID;
              Break;
            end;

          until NOT Next;
        end;

        case iType of
          1:
            begin
              if KeyHandle <> 0 then
              begin
                ExeHandle := OpenProcess(PROCESS_TERMINATE, True, Process32.th32ProcessID);
                if ExeHandle <> 0 then
                begin
                  if not TerminateProcess(ExeHandle, 0) then
                  begin
                    Result.Result_int := 0;
                    Result.Result_Str := '종료 실패';
                  end
                  else
                  begin
                    Result.Result_int := 1;
                    Result.Result_Str := '처리 완료';
                  end;
                end
                else
                begin
                  Result.Result_int := 0;
                  Result.Result_Str := '처리 실패';
                end;
              end;
            end;
          2:
            begin
              if KeyHandle <> 0 then
                Result.Result_int := 1
              else
                Result.Result_int := 0;
            end;
        end;
      end;
  end;
end;

function TDM.CopyArr(const c: array of String): TDyanmicArr_Str;
var
  i: Integer;
begin
  SetLength(Result, Length(c));
  for i := Low(c) to High(c) do
  begin
    Result[i] := c[i];
  end;

  // Move(c[Low(c)], Result[0], Sizeof(c));
end;

function TDM.CountStrings(sText, FindText: String): Word;
var
  i: Word;
begin
  //
  Result := 0;
  i := 1;
  repeat
    i := PosEX(FindText, sText, i);
    if i <> 0 then
    begin
      inc(Result);
      inc(i);
    end;
  until (i = 0);
end;

procedure TDM.DataModuleCreate(Sender: TObject);
var
  bWin64: BOOL;
  Res: DWORD;
begin
  if IsWow64Process(GetCurrentProcess, bWin64) then
  begin
    if bWin64 then
    begin
      bWin32 := False;
    end
    else
      bWin32 := True;
  end
  else
    RaiseLastOSError;

  ProgramPath := ExtractFilePath(Application.ExeName);
  ProgramVer := FileVersion(Application.ExeName);
  SetLength(arrPos_Info, 0);

  iniInfo(0, 'C:\FOODCAFE\AIRPOS.ini');
  iniInfo(0, 'C:\FOODCAFE\Servers.ini');
  iniInfo(0, ProgramPath + 'AirControl.ini');

  AddFontResource(PChar(ProgramPath + 'Font\D2Coding.ttf'));
  AddFontResource(PChar(ProgramPath + 'Font\GodoB.ttf'));
  AddFontResource(PChar(ProgramPath + 'Font\GodoM.ttf'));

  SendMessageTimeout(Application.Handle, HWND_BROADCAST, WM_FONTCHANGE, 0, 0, 10, Res);
end;

procedure TDM.DataModuleDestroy(Sender: TObject);
var
  Res: DWORD;
  i: Integer;
begin
  RemoveFontResource(PChar(ProgramPath + 'Font\D2Coding.ttf'));
  RemoveFontResource(PChar(ProgramPath + 'Font\GodoB.ttf'));
  RemoveFontResource(PChar(ProgramPath + 'Font\GodoM.ttf'));
  // SendMessage(HWND_BROADCAST, WM_FONTCHANGE, 0, 0);
  SendMessageTimeout(Application.Handle, HWND_BROADCAST, WM_FONTCHANGE, 0, 0, 10, Res);

  for i := Low(arrPrnOptionList) to High(arrPrnOptionList) do
    FreeAndNil(arrPrnOptionList[i].slMemo);
end;

function TDM.DBConnect: Boolean;
begin
  //
  Result := False;
  if NOT FileExists(ProgramPath + 'fbclient.dll') then
  begin
    GetPopup('연동 라이브러리 파일을 찾을 수 없습니다.||fbClient.dll Not Found');
    Exit
  end
  else if FDConn.Connected then
    DBDisConnect;

  try
    with FDConn do
    begin
      DriverName := 'FB';
      with Params do
      begin
        DriverID := 'FB';
        if HostIP = '127.0.0.1' then
          Database := DBPath + '\POS'
        else
          Database := HostIP + ':' + DBPath + '\POS';
        Password := 'masterkey';
        UserName := 'sysdba';
      end;

      Connected := True;
      Result := Connected;
    end;
  except
    ON E: Exception do
    begin
      SetLog('DB CONNECT Fail :' + E.Message);
    end;
  end;
end;

function TDM.DBDisConnect: Boolean;
begin
  FDConn.Connected := False;
  Result := NOT FDConn.Connected;
end;

procedure TDM.DBSQLClear;
begin
  //
  FDQ.Active := False;
  FDQ.SQL.Clear;
end;

procedure TDM.DelNotification(sName: String);
begin
  WinNotification.CancelNotification(sName);
end;

procedure TDM.FileDownload(sDonwloadURL, sFileName: String);
var
  i: Cardinal;
  sPath: String;
  HRes: HRESULT;
  pwcPath: PWideChar;
begin
  //
  if Assigned(DownloadURL) then
  begin
    DM.GetPopup(0, '다운로드 불가', '앞에 다운로드가 완료후 진행 가능합니다.' + #13#10 + '[다중 파일다운로드 불가]', '');
    Exit;
  end;

  try
    // 다운로드 폴더 경로
    HRes := SHGetKnownFolderPath(StringToGUID('{374DE290-123F-4565-9164-39C4925E467B}'), 0, 0, pwcPath);
    if HRes = S_OK then
    begin
      sPath := pwcPath + '\' + sFileName;
    end
    else
    begin
      if SaveDialog.Execute then
      begin
        sPath := SaveDialog.FileName;
      end
      else
      begin
        if CreateDir('Download') then
          sPath := '.\Download\' + sFileName
        else
        begin
          GetPopup(0, '안내', '저장 경로를 처리할 수 없습니다.', '');
          Exit;
        end;
      end;
    end;
  except
    ON E: Exception do
    begin
      SetLog('FilePath Error : ' + E.Message);
      Exit;
    end;
  end;

  //
  DownloadURL := TDownloadURL_Thread.Create(True);
  TRY
    try
      with DownloadURL do
      begin
        sURL := sDonwloadURL;
        sSavePath := sPath;
        Resume;
      end;
      Timer_DownloadChk.Enabled := True;
    except
      ON E: Exception do
      begin
        SetLog('Download 처리실패 : ' + E.Message);
      end;
    end;
    ShowNotification('Download', '파일 다운로드가 시작되었습니다.');
  FINALLY
  END;

end;

procedure TDM.FileSaveComplete;
begin
  //
  if DownloadURL.bOK then
    ShowNotification('Download', '파일 다운로드가 완료되었습니다.')
  else
    ShowNotification('Download', '파일 다운로드가 실패/취소하었습니다.');
  FreeAndNil(DownloadURL);
end;

procedure TDM.FileUpdateChk;
const
  ReqURL = '';
begin
  // 파일 최신버전 체크
  bUpdate := HTTP_Send(ReqURL, 'post', 'application/json', 'utf-8') <> ProgramVer;
end;

function TDM.FileVersion(sPath: String): String;
var
  iSize: Integer;
  dw: DWORD;
  pBuffer: PWideChar;
  pvFileInfo: PVSFixedFileInfo;
  uLen: UINT;
begin
  // 파일 버전
  Result := '';
  try
    iSize := GetFileVersionInfoSize(PChar(sPath), dw);
    if iSize = 0 then
    begin
      // 파일 없음
    end
    else
    begin
      try
        GetMem(pBuffer, iSize);
        if GetFileVersionInfo(PChar(sPath), 0, iSize, pBuffer) then
        begin
          if VerQueryValue(pBuffer, '\\', Pointer(pvFileInfo), uLen) then
          begin
            with TVSFixedFileInfo(pvFileInfo^) do
            begin
              Result := Format('%d.%d.%d.%d', [HiWord(dwFileVersionMS), LoWord(dwFileVersionMS), HiWord(dwFileVersionLS),
                LoWord(dwFileVersionLS)]);
            end;
          end;
        end;
      finally
        FreeMem(pBuffer);
      end;
    end;
  except
    on E: Exception do
    begin
      SetLog('File Version Exception : ' + E.Message);
    end;
  end;
end;

function TDM.GetComPort: TResult_IS;
var
  i: Integer;
  Reg: TRegistry;
  regList: TStringList;
begin
  try
    try
      Reg := TRegistry.Create;
      regList := TStringList.Create;

      with Reg do
      begin
        RootKey := HKEY_LOCAL_MACHINE;
        if OpenKey('\HARDWARE\DEVICEMAP\SERIALCOMM', False) then
        begin
          GetValueNames(regList);

          if regList.Count = 0 then
          begin
            Result.Result_int := 0;
            Result.Result_Str := '사용 가능한 포트가 없습니다.';
          end
          else
          begin
            for i := 0 to regList.Count - 1 do
            begin
              Result.Result_Str := Result.Result_Str + ReadString(regList[i]) + #13#10;
            end;
            Result.Result_int := regList.Count;
          end;
        end;
      end;
    except
      ON E: Exception do
      begin
        ShowMessage('프린터 포트 가져오는 중 오류 : ' + #13#10 + E.Message);
      end;
    end;
  finally
    Reg.CloseKey;
    FreeAndNil(regList);
    FreeAndNil(Reg);
  end;
end;

procedure TDM.GetENVList;
var
  i: Byte;
begin
  SetLength(arrENV_Nav, High(arrENV_Category) + 1);
  for i := Low(arrENV_Nav) to High(arrENV_Nav) do
  begin
    case i of
      0: // 매장관리
        begin
          SetLength(arrENV_Nav[i], 4);
          arrENV_Nav[i, 0] := '매장정보관리';
          arrENV_Nav[i, 1] := '운영정보관리';
          // arrENV_Nav[i, 2] := '배달관리';
          arrENV_Nav[i, 3] := '관리자(ASP) 관리';
        end;
      1: // 일반설정
        begin
          SetLength(arrENV_Nav[i], 2);
          arrENV_Nav[i, 0] := '기타설정';
          arrENV_Nav[i, 1] := '보조모니터 설정';
        end;
      2: // 장치관리
        begin
          SetLength(arrENV_Nav[i], 3);
          arrENV_Nav[i, 0] := '주변장치관리';
          arrENV_Nav[i, 1] := '출력용지관리';
          arrENV_Nav[i, 2] := '가상포트관리';
        end;
      3: // 결제관리
        begin
          SetLength(arrENV_Nav[i], 2);
          arrENV_Nav[i, 0] := '결제관리';
          // arrENV_Nav[i, 1] := '간편결제관리';
        end;
{$IFDEF DEBUG}
      4:
        begin
          SetLength(arrENV_Nav[i], 1);
          arrENV_Nav[i, 0] := 'Unused[상품관리(Demo)]';
        end;
{$ENDIF}
    end;
  end;

  SetLength(arrData_Nav, High(arrData_Category) + 1);
  for i := Low(arrData_Nav) to High(arrData_Nav) do
  begin
    case i of
      0:
        begin
          SetLength(arrData_Nav[i], 3);
          arrData_Nav[i, 0] := '상품 관리';
          arrData_Nav[i, 1] := '세트 연결그룹관리';
          arrData_Nav[i, 2] := '세트 관리';
        end;
      1:
        begin
          SetLength(arrData_Nav[i], 3);
          arrData_Nav[i, 0] := '상품배치관리';
          arrData_Nav[i, 1] := '좌석 관리';
          arrData_Nav[i, 2] := '사물함(락커) 관리'; // 시간제 전용
        end;
{$IFDEF DEBUG}
      2:
        begin
          SetLength(arrData_Nav[i], 3);
          arrData_Nav[i, 0] := '회원목록';
          arrData_Nav[i, 1] := '적립/사용 내역';
          arrData_Nav[i, 2] := '문자SMS 내역';
        end;
{$ENDIF}
    end;
  end;

  SetLength(arrSystem_Nav, High(arrSystem_Category) + 1);
  for i := Low(arrSystem_Nav) to High(arrSystem_Nav) do
  begin
    case i of
      0:
        begin
          SetLength(arrSystem_Nav[i], 2);
          arrSystem_Nav[i, 0] := '원격 관리';
          arrSystem_Nav[i, 1] := '장치 원격설정';
          // arrSystem_Nav[i, 2] := '장치별 설정관리';
        end;
    end;
  end;
end;

function TDM.GetExecute(ProcessName: String): TResult_IS;
begin

end;

function TDM.GetfileInfo: TFileInfos;
begin

end;

{ TIdHTTP_Thread }
constructor TIdHTTP_Thread.Create;
begin
  bRecv := False;
  bUTF := False;
end;

procedure TIdHTTP_Thread.Execute;
begin
end;

{ TDownloadURL_Thread }
constructor TDownloadURL_Thread.Create(CreateSuspended: Boolean);
begin
  Inherited Create(False);
  bOK := False;
  bComplete := False;
  bCancel := False;
  bAutoOpen := True;

end;

destructor TDownloadURL_Thread.Destory;
begin
  inherited;
  //
end;

procedure TDownloadURL_Thread.DownAfterDownload(Sender: TObject);
begin
  //
  bComplete := True;
end;

procedure TDownloadURL_Thread.DownProgress(Sender: TDownLoadURL; Progress, ProgressMax: Cardinal; StatusCode: TURLDownloadStatus;
  StatusText: String; var Cancel: Boolean);
begin
  Cancel := bCancel;
  iNOW := Progress;
  iMAX := ProgressMax;
  sStatusCode := StatusCode;
  sStatusText := StatusText;
end;

procedure TDownloadURL_Thread.Execute;
var
  DownURL: TDownLoadURL;
  HR: HRESULT;
begin
  inherited;
  DeleteUrlCacheEntry(PWideChar(sURL));
  DownURL := TDownLoadURL.Create(nil);
  try
    DM.SetLog('사용자 다운로드 요청');
    DownURL.URL := sURL;
    DownURL.FileName := sSavePath;
    DownURL.AfterDownload := DownAfterDownload;
    DownURL.OnDownloadProgress := DownProgress;
    HR := DownURL.ExecuteTargetResult(nil);
    DM.SetLog('사용자 다운로드 상태확인');
    if HR = S_OK then
    begin
      DM.SetLog('사용자 다운로드 완료');
      bOK := True;
      if bAutoOpen then
      begin
        ShellExecute(Application.Handle, 'open', 'explorer.exe', PChar(sSavePath), nil, SW_NORMAL);
        DM.SetLog('다운로드 파일 실행');
      end;
    end
    else if bCancel then
    begin
      DM.SetLog('사용자 다운로드 취소');
    end
    else
    begin
      DM.GetPopup(0, '파일 다운로드 실패', '파일 다운로드를 실패하였습니다.' + #13#10 + '네트워크 상태를 확인해주세요.', '');
    end;
  finally
    if Assigned(DownURL) then
    begin
      FreeAndNil(DownURL);
      Sleep(1000);
      FreeAndNil(HR);
      DM.SetLog('사용자 다운로드 처리종료');

      DownURL := nil;
    end;
  end;
end;

function TDM.DBCodeChk(sTable, sColumn, sChkCode: String): Boolean;
begin
  Result := False;
  if NOT DBConnect then
    Exit
  else
  begin
    if Trim(sChkCode) = '' then
      Exit;

    bSQLExecute := True;
    DBSQLClear;
    try
      with DM.FDQ do
      begin
        SQL.Text := 'SELECT * FROM ' + sTable + ' WHERE ' + sColumn + ' = :CODE';
        ParamByName('CODE').AsString := DM.AnsiFormat(sChkCode);

        OPEN;
        Result := Not Eof;
      end;
    finally
      DM.FDQ.CLose;
      DM.DBDisConnect;
      bSQLExecute := False;
    end;
  end;

end;

function TDM.GetStocks: Boolean;
var
  StockData: TStock_Info;
begin
  //
  Result := False;
  DELETE(arrStockInfo, 0, Length(arrStockInfo));
  if NOT DM.DBConnect then
    Exit
  else
  begin
    try
      try
        bSQLExecute := True;
        with DM.FDQ do
        begin
          DM.DBSQLClear;
          SQL.Text :=
            'SELECT STOCKCODE, STOCKNAME, SALEAMT, GUBUNCODE, KITPRN, MAEIPAMT, NOWMAEIP, STANDARD, UNIT, VAT, QTY, SETCODE FROM HSTOCK';
          SQL.Add(' ORDER BY STOCKCODE DESC ');
          OPEN;
          while Not Eof do
          begin
            with StockData do
            begin
              sStockCode := FieldByName('STOCKCODE').AsString;
              sStockName := FieldByName('STOCKNAME').AsString;
              iStockAMT := FieldByName('SALEAMT').AsInteger;
              sGubunCode := FieldByName('GUBUNCODE').AsString;
              sKitPrn := FieldByName('KITPRN').AsString;
              iMaeipAMT := FieldByName('MAEIPAMT').AsInteger;
              iNowMaeip := FieldByName('NOWMAEIP').AsInteger;
              sStandard := FieldByName('STANDARD').AsString;
              sUnit := FieldByName('UNIT').AsString;
              sVAT := FieldByName('VAT').AsString;
              iQTY := FieldByName('QTY').AsInteger;
              sSETCODE := FieldByName('SETCODE').AsString;

              bCHk := False;
            end;
            System.Insert(StockData, arrStockInfo, High(arrStockInfo) + 1);
            Next;
          end;
        end;
        Result := True;
      except
        ON E: Exception do
        begin
          DM.SetLog('상품 가져오는 중 오류 ' + E.Message);
        end;
      end;
    finally
      FDQ.CLose;
      DBDisConnect;
      bSQLExecute := False;
    end;
  end;
end;

function TDM.HTTP_Send(sURL, sMethod, sContent, sEncoding: String): String;
var
  Http_Res: IHTTPResponse;
begin
  with HttpClient do
  begin
    ContentType := sContent;
    AcceptEncoding := sEncoding;
    Asynchronous := False;
  end;

  if sMethod = 'GET' then
  begin
    Http_Res := HttpClient.Get(sURL, nil);
    if Http_Res.StatusCode = 200 then
      Result := Http_Res.ContentAsString(TEncoding.UTF8)
    else
      Result := 'Fail';
  end;
end;

function TDM.GetSets: Boolean;
var
  StockSet: TStock_Set;
  i: Byte;
begin
  Result := False;
  DELETE(arrStockSet, 0, Length(arrStockSet));
  if NOT DBConnect then
    Exit
  else
  begin
    try
      bSQLExecute := True;
      StockSet.sCODE := '';
      StockSet.sSETNAME := '세트 미지정';
      SetLength(StockSet.iSEQ, 10);
      for i := 0 to 9 do
        StockSet.iSEQ[i] := 0;
      System.Insert(StockSet, arrStockSet, 0);

      with FDQ do
      begin
        DBSQLClear;
        SQL.Text := 'SELECT * FROM HSET ORDER BY SETCODE';
        OPEN;
        while Not Eof do
        begin
          System.DELETE(StockSet.iSEQ, 0, Length(StockSet.iSEQ));

          StockSet.sCODE := FieldByName('SETCODE').AsString;
          StockSet.sSETNAME := FieldByName('SETNAME').AsString;
          StockSet.iCNT := FieldByName('CNT').AsInteger;
          StockSet.iSETTYPE := FieldByName('GUBUN').AsInteger;
          for i := 1 to 10 do
          begin
            if FieldByName('ISEQ' + IntToStr(i)).AsInteger <> 0 then
              System.Insert(FieldByName('ISEQ' + IntToStr(i)).AsInteger, StockSet.iSEQ, Length(StockSet.iSEQ));
          end;

          System.Insert(StockSet, arrStockSet, High(arrStockSet) + 1);
          Next;
        end;
      end;
      Result := True;
    finally
      FDQ.CLose;
      DBDisConnect;
      bSQLExecute := False;
    end;
  end;
end;

function TDM.GetSetMenus: Boolean;
var
  i: Cardinal;
  ini: TMeminiFile;
  SL: TStringList;

  iISEQ, iInputAMT, iInputQTY: Word;
  sSETCODE, sMENUNAME, sDateTime: String;
begin
  Result := False;
  // 세트메뉴 정보 가져오기
  if NOT DM.DBConnect then
    Exit
  else
  begin
    bSQLExecute := True;
    DELETE(arrStockSetMenus, 0, Length(arrStockSetMenus));
    SetLength(arrStockSetMenus, 100);
    for i := Low(arrStockSetMenus) to High(arrStockSetMenus) do
      arrStockSetMenus[i].iSEQ := i + 1;

    DM.DBSQLClear;
    try
      with DM.FDQ do
      begin
        SQL.Add(' SELECT HS.ISEQ, HS.SETCODE, S.STOCKNAME, HS.INPUTAMT, HS.INPUTQTY, HS.UPDT FROM HSETMENU HS ');
        SQL.Add(' INNER JOIN HSTOCK S ON HS.SETCODE = S.STOCKCODE ORDER BY ISEQ, INPUTQTY ASC');
        OPEN;
        while Not Eof do
        begin
          iISEQ := FieldByName('ISEQ').AsInteger;
          sSETCODE := FieldByName('SETCODE').AsString;
          sMENUNAME := FieldByName('STOCKNAME').AsString;
          iInputAMT := FieldByName('INPUTAMT').AsInteger;
          iInputQTY := FieldByName('INPUTQTY').AsInteger;
          sDateTime := FieldByName('UPDT').AsString;

          with arrStockSetMenus[iISEQ - 1] do
          begin
            System.Insert(sSETCODE, sOption_CODE, High(sOption_CODE) + 1);
            System.Insert(sMENUNAME, sOption_Name, High(sOption_Name) + 1);
            System.Insert(iInputAMT, iOption_AMT, High(iOption_AMT) + 1);
            System.Insert(iInputQTY, iOption_SEQ, High(iOption_SEQ) + 1);
            System.Insert(sDateTime, sOption_DateTime, High(sOption_DateTime) + 1);
          end;
          Next;
        end;
        Result := True;
      end;
    finally
      DBDisConnect;
    end;

    ini := TMeminiFile.Create(ProgramPath + 'SETMENU_NAME.ini', TEncoding.UTF8);
    SL := TStringList.Create;
    try
      with ini do
      begin
        for i := Low(arrStockSetMenus) to High(arrStockSetMenus) do
        begin
          with arrStockSetMenus[i] do
          begin
            sName := ini.ReadString('SET_ISEQ_' + IntToStr(i + 1), 'CATEGORY', '');
          end;
        end;
      end;
      Result := True;
    finally
      FreeAndNil(SL);
      ini.Free;
      bSQLExecute := False;
      DBDisConnect;
    end;
  end;
end;

function TDM.GetMenuCategros: Boolean;
var
  Menu_Category: TMenu_Category;
  i: Integer;
begin
  // 메뉴 분류 가져오기
  Result := False;
  if NOT DM.DBConnect then
    Exit
  else
  begin
    DELETE(arrMenuCategory, 0, Length(arrMenuCategory));
    SetLength(arrMenuCategory, iMENU_CATEGORY_MAX);
    ZeroMemory(@arrMenuCategory[0], Length(arrMenuCategory));

    bSQLExecute := True;
    try
      with FDQ do
      begin
        SQL.Text := 'SELECT ISEQ, GUBUNNM, FONTCOLOR, BACKCOLOR FROM HMENUGUBUN ORDER BY ISEQ ASC';
        OPEN;

        while Not Eof do
        begin
          i := FieldByName('ISEQ').AsInteger - 1;
          with arrMenuCategory[i] do
          begin
            sCategory_Name := FieldByName('GUBUNNM').AsString;
            sCategory_FontColor := IntToStr(StrToIntDef(FieldByName('FONTCOLOR').AsString, 0));
            sCategory_BackColor := IntToStr(StrToIntDef(FieldByName('BACKCOLOR').AsString, 0));
          end;
          Next;
        end;
      end;
      Result := True;
    finally
      bSQLExecute := False;
      DBDisConnect;
    end;
  end;
end;

function TDM.GetMenus: Boolean;
var
  i, j: Byte;
begin
  // 메뉴 분류 가져오기
  Result := False;
  if NOT DM.DBConnect then
    Exit
  else
  begin
    DELETE(arrMenu, 0, Length(arrMenu));
    SetLength(arrMenu, iMENU_CATEGORY_MAX);
    for i := Low(arrMenu) to High(arrMenu) do
    begin
      SetLength(arrMenu[i], iMENU_MAX);
      ZeroMemory(@arrMenu[i, 0], iMENU_MAX);
    end;
    DBSQLClear;
    bSQLExecute := True;
    try
      with FDQ do
      begin
        SQL.Add('SELECT HM.ISEQ, HM.MENUNO, HM.STOCKCODE, HS.STOCKNAME, HS.SALEAMT, HM.FONTCOLOR, HM.BACKCOLOR FROM HMENU HM');
        SQL.Add('INNER JOIN HSTOCK HS');
        SQL.Add('ON HM.STOCKCODE = HS.STOCKCODE');
        SQL.Add('WHERE HM.MENUNO <= 125');
        SQL.Add('ORDER BY HM.ISEQ, HM.MENUNO ASC');
        OPEN;
        while Not Eof do
        begin
          i := FieldByName('ISEQ').AsInteger - 1;
          j := FieldByName('MENUNO').AsInteger - 1;
          with arrMenu[i, j] do
          begin
            sMenu_CODE := FieldByName('STOCKCODE').AsString;
            sMenu_Name := FieldByName('STOCKNAME').AsString;
            iMenu_AMT := FieldByName('SALEAMT').AsInteger;
            sMenu_BackColor := IntToStr(StrToIntDef(FieldByName('BACKCOLOR').AsString, 0));
            sMenu_FontColor := IntToStr(StrToIntDef(FieldByName('FONTCOLOR').AsString, 0));
          end;

          Next;
        end;
        Result := True;
      end;
    finally
      bSQLExecute := False;
      DBDisConnect;
    end;
  end;
end;

function TDM.GetTable: Boolean;
var
  FloorInfo: TFloor_Info;
  TableInfo: TTable_Info;
  i, j, iSEQ, iDiv: SmallInt;
begin
  Result := False;
  if NOT DM.DBConnect then
    Exit
  else
  begin
    bSQLExecute := True;

    // 층수
    try
      DELETE(arrFloor, 0, Length(arrFloor));
      try
        DBSQLClear;
        with FDQ do
        begin
          SQL.Text := 'SELECT POSNO, TABLECOUNT, FILLER2 FROM HPOS ORDER BY POSNO';
          OPEN;

          while Not Eof do
          begin
            with FloorInfo do
            begin
              // iFloor := FieldByName('POSNO').AsInteger;
              sFloorName := FieldByName('FILLER2').AsString;
              iTableCnt := FieldByName('TABLECOUNT').AsInteger;
            end;
            System.Insert(FloorInfo, arrFloor, Length(arrFloor));
            Next;
          end;
        end;

        // 좌석
        DELETE(arrTable, 0, Length(arrTable));
        if Length(arrFloor) = 0 then
          Exit;

        SetLength(arrTable, Length(arrFloor));

        DBSQLClear;
        with FDQ do
        begin
          SQL.Text := 'SELECT POSNO, ISEQ, TNAME, POSX, POSY, WIDTH, HEIGHT, COCOLOR FROM HTABLE_NM ORDER BY posno, iseq';
          OPEN;

          while Not Eof do
          begin
            with TableInfo do
            begin
              {
                iFloorNo := FieldByName('POSNO').AsInteger;
                iTableNo := FieldByName('ISEQ').AsInteger;
              }
              i := FieldByName('POSNO').AsInteger;
              j := FieldByName('ISEQ').AsInteger;

              sTableName := FieldByName('TNAME').AsString;
              sTableTag := FieldByName('COCOLOR').AsString;
              iTable_X := FieldByName('POSX').AsInteger;
              iTable_Y := FieldByName('POSY').AsInteger;
              iTable_W := FieldByName('WIDTH').AsInteger;
              iTable_H := FieldByName('HEIGHT').AsInteger;

              if sTableName = '' then
              begin
                if i = 1 then
                  sTableName := IntToStr(j)
                else
                  sTableName := IntToStr(i) + '-' + IntToStr(j);
              end;

              if iTable_W = 0 then
              begin
                case TableSizeGB of
                  1: // 6 X 6
                    iDiv := 6;
                  2: // 7 X 8
                    iDiv := 7;
                  3: // 9 X 12
                    iDiv := 9;
                end;

                iTable_W := Round(850 / iDiv)
              end;

              if iTable_H = 0 then
              begin
                case TableSizeGB of
                  1: // 6 X 6
                    iDiv := 6;
                  2: // 7 X 8
                    iDiv := 8;
                  3: // 9 X 12
                    iDiv := 12;
                end;
                iTable_H := Round(710 / iDiv);
              end;

              if iTable_X = 0 then
              begin
                case TableSizeGB of
                  1: // 6 X 6
                    iDiv := 6;
                  2: // 7 X 8
                    iDiv := 7;
                  3: // 9 X 12
                    iDiv := 9;
                end;
                iTable_X := (j - 1) mod iDiv * iTable_W + 8;
              end;

              if iTable_Y = 0 then
              begin
                case TableSizeGB of
                  1: // 6 X 6
                    iDiv := 6;
                  2: // 7 X 8
                    iDiv := 7;
                  3: // 9 X 12
                    iDiv := 9;
                end;
                iTable_Y := (j - 1) div iDiv * iTable_H + 8;
              end;

              iSEQ := i - 1;
              bUsed := arrFloor[iSEQ].iTableCnt >= j;
              System.Insert(TableInfo, arrTable[iSEQ], Length(arrTable[iSEQ]));
            end;
            Next;
          end;
        end;
        Result := True;
      except
        ON E: Exception do
        begin
          SetLog('좌석 불러오기 실패 : ' + E.Message);
        end;
      end;
    finally
      bSQLExecute := False;
      DBDisConnect;
    end;
  end;
end;

function TDM.GetlockerTag: Boolean;
var
  LockerInfo: TLocker_info;
begin
  Result := False;
  if NOT DM.DBConnect then
    Exit
  else
  begin
    bSQLExecute := True;
    try
      DELETE(arrLocker, 0, Length(arrLocker));
      DBSQLClear;
      try
        with FDQ do
        begin
          SQL.Text := 'SELECT SEQ, TAG, USEFLAG, STATIC FROM TAG ORDER BY SEQ';
          OPEN;

          while Not Eof do
          begin
            with LockerInfo do
            begin
              iSEQ := FieldByName('SEQ').AsInteger;
              sTAG := FieldByName('TAG').AsString;
              sUSED := FieldByName('USEFLAG').AsString;
              sSTATIC := FieldByName('STATIC').AsString;
            end;

            System.Insert(LockerInfo, arrLocker, Length(arrLocker));
            Next;
          end;
          Result := True;
        end;
      except
        ON E: Exception do
        begin
          SetLog('사물함(락커) 불러오기 실패 : ' + E.Message);
        end;
      end;
    finally
      bSQLExecute := False;
      DBDisConnect;
    end;
  end;
end;

end.
